An Absolute Beginner's Guide To Programming
With Perl

So you want to learn to program?  Good.  Let's do that.

First things first.


What is programming?

Programming is telling a computer what to do.  We do that by writing programs.  We have to speak a language that the computer understands.  We're going to use Perl.


What is Perl?

Wikipedia: Perl is a high-level, general-purpose, interpreted, dynamic programming language.

What?  Perl is a kick-ass scripting language.  Meaning programs don't need to be compiled before running.  Perl programs are compiled when you run them ("at runtime"), making it a great cross-platform language.

It has very powerful regular expression implementation (think: search and replace on steroids), which makes it great for processing files.  In fact, this is what what Perl was created to do: parse log files.

It doesn't have strong graphics capabilities (there is a module called PerlTK to create GUIs in Perl) so it is typically run from the command line.


Why do I like Perl?  It's very powerful, yet easy and quick to write and debug, and can be run just about anywhere.  I am usually wanting to analyze, modify, and/or generate files - Perl is ideal for this.


Perl is not well-suited for every task.

If you want to do have interactive graphics, take a look at Processing.

If you want to do interactive audio, take a look at Pure Data.

If you want to program embedded devices, take a look at Arduino or Python (on Raspberry Pi).

But no matter which of these languages you end up using, Perl makes a good place to learn.


Why Perl?

Something happened in 1972 - The C Programming Language.  Dennis Ritchie was co-developing the Unix operating system and was unsatisfied with the programming languages available.  So he designed a new programming language, called C.  He and Brian W. Kernighan wrote a book to describe the language, and it is one of the best computer programming books ever written.  It is well-written, clear, and concise (the first edition is only about 120 pages).

C is a simple yet powerful and flexible language.  Most high-level languages that have been introduced since have been largely based on C.  They are dialects of the same language; if you understand C, you can more or less read (and with a little work, write) the others.

So why not start with C?

C has some quirks that make doing simple things more complicated than they need to be (particularly when it comes to string manipulation), and make it easy for you to shoot yourself in the foot.

C is a compiled language, which requires you to install and use a compiler, and slows down the process of writing and running your program.

While C can be portable, platform-specific implementation details can make it a challenge share your program with others.


Perl is very C-like, so you can move to other C-like languages easily.  There is no (separate) compilation step.  And your programs can easily run on other computers.

Perl has a reputation for being intimidating, confusing, and unreadable.  This reputation is not entirely unwarranted (they have contests to see who can create the shortest, least readable Perl program, after all).  But it doesn't have to be that way.

$i=4;$|=@f=map{("!"x$i++)."K$_^\x{0e}"}
"BQI!\\","BQI\\","BQI","BQ","B","";push
@f,reverse@f[1..5];@f=map{join"",undef,
map{chr(ord()-1)}split""}@f;{;$f=shift@
f;print$f;push@f,$f;select undef,undef,
undef,.25;redo;last;exit;print or die;}


Let's get started!


What you need:

A computer
(duh)

Perl
If you have a Mac or Linux machine, it's already there

If you use Windows, download ActivePerl (free) community edition
http://www.activestate.com/activeperl/downloads

Text editor
Any basic text editor will do, but you really want one that is designed for programming

TextWrangler is free for the Mac
BBEdit is worth the $50 if you can afford it and do a lot of this stuff
http://barebones.com/

Notepad++ is free for Windows
http://notepad-plus-plus.org/
TextPad is not free, but is only $27 and is a little more robust
http://www.textpad.com/


How these things always start: Hello World

Create a text file named 01_hello_world.pl and type:

	print "Hello, World!\n";

save the file and from the command line and type:

$ perl 01_Hello_World.pl

hit enter and you'll see:

Hello, World!

Congratulations!  You're a programmer.


OK, it might help if you understood what's going on here.


print sends the text between the double quotes to the console. The semicolon (;) marks the end of the line.

What about "\n"?  It's a escaped character, in this case a newline.  It is a LF or CF/LF, depending on what computer is being used.  If you didn't include this, the next command line prompt would come right after the output of the program:

$ perl 01_Hello_World.pl
Hello, World!$ perl 01_Hello_World.pl
Hello, World!$

This isn't very pretty and can get confusing.  It's a good practice to make sure you always output a \n at the end of your program's output.

There are lots of escape characters that do similar things.

In Perl (and most C-like languages), there are general rules, with plenty of exceptions. A good example of this is the semicolon. Statements in Perl end with semicolons, so most lines end with a semicolon, except when they don't.

Perl does not care too much about (extra) whitespace and line breaks because it relies on semicolons to know how the program is divided up.

First rule of Perl is there's always a half dozen ways to do things. And chances are, there is always a shorter way to do things.  In fact, you can do the Hello World program on the command line without a file at all:

$ perl -e 'print "Hello, World!\n";'

But most useful programs are too complex to do inline.  So we'll do it the long way.

02_hello_world.pl:

	#!/usr/bin/perl
	use strict;          # enforce good programming practices

	print "Hello, World!\n";

We're adding a few things here:

Comments are started with '#'.  Everything on a line after a '#' is ignored, and can be used for explanation or notes

#!/usr/bin/perl is a special comment that tells the shell what program to use to interpret the file.  Perl doesn't care about this, but Mac and Linux computers do.  Windows, not so much.  But it's good practice to include it anyway.  For Linux or the Mac, it allows you to skip the "perl" part in the command.  But you may have to change the path listed to match where Perl is installed.  On Linux and Mac computers, you can figure out the right path with the which command:

$ which perl
/usr/bin/perl

So if you set the interpreter path correctly, you can run the script like this:

$ ./02_hello_world.pl
Hello, World!

On Linux and Mac OS, you need to make sure the .pl file is set as an executable, which you can do using the chmod command:

$ chmod a+x *.pl

Perl has a module mechanism. Modules are invoked with "use".  In this case, "strict" is a pseudo module, but is being used as a compiler directive, telling Perl to require some things that are good programming practices anyway.  Including "use strict" will keep you from making mistakes and help troubleshoot errors.

Another good module to use is "warnings" which give slightly more informative error messages when things go wrong.


<need a segue>


What Is A Computer?

In order for us to be able to efficiently tell the computer what to do (program it), we need to know what a computer is.

A computer is a general-purpose tool.  It does what you tell it to.  (Within reason.)

<picture of computer>

This is what the inside of a computer looks like.  Well, not really, but this shows the essentials.

You need a few things for a computer:

Processor (CPU)
Memory
Input/Output
Clock


The processor is the brains of the computer. It's basically a calculator that follows instructions.

It can only do a few things:

1) read/write data into memory
2) add two numbers together
3) compare two numbers
4) make decisions based on the result of these things

This is a necessary oversimplification, but it is basically true.

Perl, like any programming language, has built-in functions which does combinations of the above capabilities to accomplish specific things.  "print" is one of these - it outputs a string to the terminal.


Memory is a place where things can be (temporarily) stored, including programs and data.  Traditionally, memory is the vernacular for "RAM" (Random Access Memory) and is volatile - meaning it only persists while the computer is on.  Traditionally, "storage" is what we would call long-term memory - non-volatile storage such as hard drives, floppy disks, and data tapes.  Today, with solid state disks, the difference between memory and storage is being blurred, and more and more computers are using a single store of non-volatile solid state devices for both memory and storage.

Memory and storage may be physically converging, but for reasons of tradition, they are handled differently via controllers that manage the two types of devices.


Input/Output is how we get data into and out of the computer. These take multiple forms - keyboard, monitor, files, printer, camera, microphone, speaker, etc.  We will focus on what we call "Standard I/O" (STDIO) - the keyboard and terminal - and files.


Clock - if the processor is the brains of the computer, the clock is its heart.  The clock is the synchronizer which controls the movement of data.


Data Representation

We don't care about data.  What we care about is information.  But we need to store that information as data.

Information Theory (The Short Form)

Information is a stream of symbols.  We humans use many symbols

A, B, C, 1, 2, 3, ., !, *, (, ), -, &c.

We use data to represent, store, and transmit symbols.  Information theory is the study of efficient use of data.

Computers only use electricity for data.  Digital computers don't have as many symbols as humans do.  The only have two:

0

and

1

They could have more, and in the future they probably will.

But the way we build comptuers now, they use a voltage (usually 5 volts) to represent 1 and another (usually 0 volts) to represent 0.

(Kind of.)

(Mostly.)

Because there are two symbols, we call this binary (or base 2).  Each symbol is a Binary digIT - or "bit."

10101001 = 8 bits = 1 byte = 2 nibbles

Bits by themselves don't mean anything but we assign values to them or combinations of them.

Humans usually have ten fingers so we count in decimal - or base 10.  Decimal has ten symbols:

0 1 2 3 4 5 6 7 8 9

(Note that I put 0 first.)

How To Count

(Yeah, I know you learned this in kindergarden, but you probably learned wrong.)

Start at 0.  (Pretend there are infinite leading zeros - 0 = 00000000.)
Increment the right-most digit by one. (0, 1, 2, 3, 4, 5, 6, 7, 8, 9.)
When you run out of symbols, reset to 0 and increment the digit to the left ("carry the one").
Repeat.

00 01 02 03 04 05 06 07 08 09 10 11 12 &c.

Binary is no different.  We just run out of symbols more frequently.

0000 0001 0010 0011 0100 0101 0110 0111 1000 &c.

We can convert between binary and decimal easily enough.

0 = 0
1 = 1
10 = 2
11 = 3
100 = 4

They don't line up very well.  But say we use 2^4 = 16 symbols - hexadecimal.  We need a few more (a total of 16) symbols:

0 1 2 3 4 5 6 7 8 9 A B C D E F

1 hex digit is exactly 4 bits, or one half a byte.

0000 = 0 = 0
0001 = 1 = 1
0010 = 2 = 2
0011 = 3 = 3
0100 = 4 = 4
0101 = 5 = 5
0110 = 6 = 6
0111 = 7 = 7
1000 = 8 = 8
1001 = 9 = 9
1010 = 10 = A
1011 = 11 = B
1100 = 12 = C
1101 = 13 = D
1110 = 14 = E
1111 = 15 = F

Because numbers in different bases can look the same, sometimes we add prefixes to identify the base.

Decimal (base 10) 0d
Binary (base 2) 0b
Hexadecimal (base 16) 0x

1 byte = 2^8 = 256 values (0x00 .. 0xFF).

Think of memory as a row of houses.  Each house stores 1 byte.  Each house has it's own address.

Why 8 bits?

It's convenient.  It can store enough values to store every letter, number, punctuation, etc. for any western alphabet (Asian languages require more).

The mapping between byte values and letters/numbers/etc. is called ASCII.  It's entirely arbitrary.  But then, this is true of all data representation (though there may be logic between the choices).

Say we need more than 256 values to represent your data?  No problem - just use more bytes.  Use two (adjacent) houses.

2 houses = 2 bytes = 16 bits = ~32 thousand values = 1 CD sample (or 1 MP3 sample if you don't know what a CD is).

4 houses = 4 bytes = 32 bits = ~4 billion values.

We can represent all positive numbers or both positive and negative numbers this way.  16 bits can be 0..65536 or -16728..16727.  But all are whole numbers.  We call these integers.

If we need fractional numbers, we call that floating point

3.14159
2.5
1.0
1000/1001

Floating point numbers are stored in a complex format that represent the number as an integer and where to put the decimal point.

6.02x10^23

Floating point numbers are typically 32 bits, but there is a double float that is 64 bits.

We can represent anything in binary but we mostly need to worry about a few data types:

characters (single byte values)
string (a string of characters)
integers
floating point numbers

Data is stored in memory.  To keep track of where it is in memory, we give the address of the house where it is stored (or the first house if it uses more than one byte) a name.  Think of it as an address book that lists the name of the variable, it's memory address, and what type of variable it is.

(Files are a little different - think of them as one big variable, with a file name instead of an address.  Each byte in the file has its own address inside the file.)


In most programming languages, you have to say what data type a variable is before using it.  This is called "declaring" the variable.  It allocates memory for the variable, setting aside a chunk of memory at a free memory address.

Perl simplifies things for you a bit.  You can actually get away without declaring your variables at all, if you don't use the strict module.  But it's good habit, so we're going to pretend we have to.

What you don't have to do is tell Perl what kind of data you're going to keep in the variable.  Perl is very flexible about that and can deal with all kinds of data, even converting between types as needed.  This is convenient, but you give up some efficiency and speed for this convenience.  So if you find yourself wishing your program were faster, you may want to move to a different language.

Perl only really has one data type, called a scalar.  Scalar variables are identified by a dollar sign at their beginning (like $var).  Scalars are declared with the my keyword:

my $var;

"var" is the name of the variable.  Variable names in Perl are case sensitive, so "var" is not the same as "Var".  Choosing variable names is important - you want them to indicate what the variable is for, but you want to keep it short enough to be manageable.

You can also assign a value to a variable at the time of declaration:

my $var = 1;
my $lastname = "Smith";

(OK, we've introduced a new thing here - the "=" is an operator.  We'll get back to that in a minute.)

There are two other types of variables, but they're just groups of scalars.

Arrays are a series of scalars.  They are identified by a "@" at their beginning (like @addresses).  An array can contain any number of scalars (well, almost any number), and you identify each scalar by number (like @addresses[0] or @addresses[1]).

Just as with counting, you start at zero.  The first item is item number zero.  Which takes a little getting used to.

Hashes are pairs of linked arrays, so you can think of them as an array of arrays.  Hashes are identified by a "%" at their beginning (like %price).  Hashes are basically a rudimentary database.  They are awesome, but they take some learning.

We'll get back to arrays and hashes in a bit.

03_hello_world.pl

	#!/usr/bin/perl

	use strict;		# enforce good programming practices

	my $hello_string;

	$hello_string = "Hello, World!\n";

	print "$hello_string";

So here, we're declaring a scalar variable named $hello_string, then we're putting the data "Hello, World!\n" into the variable (writing to memory), then we're using the variable in the print command instead of the string.

The text inbetween the double quotes is called a string.  (A string is essentially an array of bytes.)

When Perl sees a scalar variable inside a string, it substitutes the variable name with the contents of the variable.  (Reading memory.)  So,

	print "$hello_string";

is functionally the same as 

	print "Hello, World!\n";

The value of a variable can change (hence the name, variable).  So you can do this:

	my $hello_string;

	$hello_string = "derp";
	$hello_string = "Hello, World!\n";

	print "$hello_string";

After the first assignment, $hello_string contains "derp".  The second replaces the string "derp" with "Hello, World!\n".

The "=" is the assignment operator.  It sets the thing to the left of the operator (our variable in this case) to the value of the thing to the right of the operator (our string in this case).

Just about anything can happen to the right of the assignment operator (or, indeed, most operators).  Including another variable:

	my $a = "Hello, World!\n";
	my $hello_string = $a;









functions

scope

operators







Operators do things to bits of memory (variables or output of functions), such as addition. There are other operators that mostly do variations on addition (again, this is a bit of an oversimplification).

The decision-making component is called flow control. You can compare the value of data in memory, or the output of a function, or the result of a math calculation, and then do one of a number of things as a result.

Perl is a procedural programming language. Each program starts at the top and proceeds down line by line. You can skip forwards and back with conditional operators, code blocks, and subroutines.






Variables

One convenient thing about Perl is you don't have to worry too much about how your data is represented in memory.  Some languages like C have multiple variable types which store data in different ways.  Perl only really has one type - called a scalar.  There are also arrays, which are a collection of scalars.  There is a special type of array called a hash, which is one of the great features of Perl.

Scalar variables start with a '$'.  Arrays start with an '@'.  Hashes start with a '%'.

Perl will convert between different types of variables for you as needed. This is convenient, but has the downside that Perl may not be as efficient or optimized as a result. Perl isn't necessarily the best choice for resource-constrained applications.

You have to tell Perl about your variables, or "declare" them.  You use the "my" keyword to declare variables.  A single "my" can declare multiple variables when enclosed in parenthesis:

my $variable;
my ( $foo, $bar );

You put data into or read data from a variable with the '=' assignment operator:

$variable = "blah";
$foo = $variable;
$bar = 42;

The operation depends on which side of the '=' the variable is on.  Read on the right, write on the left.

Perl has a bunch of specialized variables, like $_, $1, @ARGV (and many more).  You cannot name a variable the same as one of these special variables, but you can use any alphanumeric string as a variable name.  Variable names, like everything in Perl, are case-sensitive.


Expressions

A variable isn't the only thing that can be on the right of the equal sign.  A variable used this way is one form of an expression, and any expression can be used on the right side of the equal sign.

Other types of expressions are strings ("Hello, World!\n"), arithmetic (1+1), conditional operators, and the output of functions (built-in or user defined).

We illustrate the various types of expressions in 06_expressions.pl:

#!/usr/bin/perl
use strict;

my $helloworld = "Hello, World!";     # assigning string at time of delcaration
my ( $i, $j );
my $result;
my ( $foo, $bar );

$i = 0;                               # assigning a number to a scalar
$bar = $i + 42;                       # assigning the result of an arithmetic expression
$foo = $bar;                          # assigning the value of a variable
$result = print "$helloworld\n";      # assigning the output of a function
$j = ( $i == 0 );                     # assigning the result of a conditional operator

print "The result of the print function is: \"$result\"\n";print "\$i: \"$i\"\n";
print "\$j: \"$j\"\n";
print "\$foo: \"$foo\"\n";
print "\$bar: \"$bar\"\n";


Which results in this output:

$ perl 06_expressions.pl
Hello, World!
The result of the print function is: "1"
$i: "0"
$j: "1"
$foo: "42"
$bar: "42"

As mentioned before, we can declare more than one variable with a single "my" by making them a list and enclosing them in parenthesis.

Next we have some examples of different types of expressions being assigned to variables.

$i = 0; assigns the numeric zero into the variable $1.

$bar = $i + 42; takes the value of $i (0) and adds 42, putting the result in $bar.

$foo = $bar; takes the value of $bar (42) and puts it in $foo.

$result = print "$helloworld\n"; calls the print function and puts the result into $result. The print function returns true if print was successful. A Boolean true in Perl  is represented by a numeric 1.  A Boolean false is anything other than a 1, usually a special value called undef, or undefined. Print almost always succeeds, so this put 1 into $result.

$j = ( $i == 0 ); introduces a new operator, the equality test "==".  It test the value of the variable on the left ($i) against the expression on the right (0) and if they are equal, the result is true (or 1).  If they are not equal, the result is undef.

One of the most common Perl mistakes is to use the assignment operator "=" and the equality operator "==".  If we did the wrong thing:

$j = ( $i = 0 );

It would not generate an error, but the result would be very different.  It would have assigned the numeric value zero to $i and then assigned the value of $i (0) to $j.  So instead of $j being at set of $i being true, we would have inadvertently assigned the wrong value to both $i and $j.


One of the nice things about Perl is it tries its best to convert different types of data for you on the fly.  When a scalar variable is used in a string expression, the value of that variable is converted into a string and substituted.  So when we did:

print "\$i: \"$i\"\n";

We have a couple new escape characters here: \$ and \".  Both of these are used to insert characters into a string that would otherwise be interpreted as the start of a variable name or a double quote character.

So $i (the second one - since the \$ puts an actual '$' character into the string, the first \$i is actually the string "$i" rather than the variable) contains a numeric zero, which is turned into the string "0" and printed.

If the variable already contains a string, the conversion is easier:

$result = print "$helloworld\n";

The variable $helloworld, which contains the string "Hello, World!", is simply replaced by the string.


Input

These programs all do the same exact thing every time, which is kind of pointless.  You don't want to have to write a new program each time you want to do something different, so we need a way to get external information to the program.  A common way to do this in Perl is with command line arguments.  03_echo.pl:

#!/usr/bin/perl
use strict;

print "@ARGV\n";

Arrays start with '@', so $ARGV is an array.  It's a special variable in Perl - it contains the command line arguments.  So now we can type some additional things on the command line:

$ perl 03_echo.pl these are arguments
these are arguments

We see what happens to an array in a string context?  It gets converted to a string, in the nicest way possible.

If we did this:

print @ARGV;

we would get the following output:

$ perl -e 'print @ARGV;' these are argumentsthesearearguments
Besides the lack of a \n at the end, notice the lack of spaces. Perl splits up arguments amongst the elements of the array @ARGV. This is helpful in this case, so we can get the arguments individually. To access the individual elements of an Array, we use square brackets to identify which:

04_echo.pl

#!/usr/bin/perl
use strict;

if ( $ARGV[0] eq undef ) {
     print "Please type your name\n";
} else {
     print "Hello, @ARGV[0], I see your last name is @ARGV[1]\n";
}

So now if you type your name as arguments to 04_echo.pl, you get the following:

$ perl 04_echo.pl Theron Trowbridge
Hello, Theron, I see your last name is Trowbridge

But what happens if you don't type anything?

$ perl 04_echo.pl
Please type your name

Some changes here.  First, since what we're expecting to be typed is a string, we are using the scalar context of the array @ARGV.  $ARGV[0] means the first item of @ARGV in scalar (string) context.  Putting @ARGV[0] or @ARGV[1] inside a double-quoted string automatically converts the array item to scalar context.  We could have used $ARGV[0] and $ARGV[1] as well.

$ARGV[0] means the first item?  Yeah - in Perl like most programming languages, you start counting at 0 (zero).  I know this can be confusing at first.  Get used to it, and even if you are in a position that you could start counting from 1, start with 0.

We're using "eq" instead of "==" to compare the first argument.  "==" is a numeric equality operator, but "eq" is a string equality operator.  Again, we're expecting strings, so we want to use "eq".  "undef" is the keyword that means undefined.  So if the first argument is empty, the expression is true, so the first code block is executed (print "Please type your name\n";).  If something was typed, the expression will be false, so it executes the else code block (print "Hello, @ARGV[0], I see your last name is @ARGV[1]\n";).

You can check for multiple if values

if ( $a eq "a" ) {
     ;
} elsif ( $a eq "b" ) {
     ;
} else {
     ;
}

You use if for the first test, each of the elsif are evaluated if the preceding tests are false.  Evaluation stops when one of the tests is true.  If none of the tests are true, the else{} block is executed.

You can make this work with the numerical equality operator if you really want to:

if ( @ARGV[0] == "" )

"" is an empty string, which a numerical value of zero, or null, which is the same as not typing anything.  But this is a special case, and you can't use "==" (easily) to test if a particular string was typed, so it's best to get in the habit of using "eq" for strings.

OK, this is all great, but the program says "type your name" so why can't you just type your name?  That's another form of input - user interactivity.

Try 07_echo_name.pl

#!/usr/bin/perl
use strict;

my ( $name, @full_name );

if ( $ARGV[0] eq undef ) {
     print "Please type your name\n";
     chomp( $name = <STDIN> );
     @full_name = split( /\s+/, $name );
     print "Hello, @full_name[0], I see your last name is @full_name[1]\n";
} else {
     print "Hello, @ARGV[0], I see your last name is @ARGV[1]\n";
}

Now, you can type your name as arguments to the script or you can respond when it says type your name:

$ perl 07_echo_name.pl
Please type your name
Theron Trowbridge
Hello, Theron, I see your last name is Trowbridge

<STDIN> is in input operator.  Specifically it's a line input operator that reads from the keyboard.  You can read from a file in a similar manner.  But we'll get to that in a bit.

chomp() is a function that removes extraneous whitespace from a string.  We use it in this case because otherwise the return that you press after typing your name will get included in the input.

We could make this longer if we wanted:

$name = <STDIN>;
chomp( $name );

But the tendency in Perl is to combine lines when possible.  It's easy to get carried away with this and render code unreadable, which gives Perl it's reputation for being indeciperable.  So try not to get carried away.

Notice that we have two very similar lines that differ only in the array items being used?  One repeated line is not that big a deal, but it's easy to have large duplicate blocks of code, which makes your code bigger and less efficient.  And if you make a change to it in one place but not in all, you can have unexpected results.

Any time you have common code you want to be able to call from multiple points in your code, you can create a subroutine.

08_echo_name:

#!/usr/bin/perl
use strict;

my ( $name, @full_name );

if ( $ARGV[0] eq undef ) {
     print "Please type your name\n";
     chomp( $name = <STDIN> );
     @full_name = split( /\s+/, $name );
     print( respond( $full_name[0], $full_name[1] ) );
} else {
     print( respond( $ARGV[0], $ARGV[1] ) );
}

sub respond {
     my $first = @_[0];
     my $last = @_[1];
     return( "Hello, $first, I see your last name is $last\n" );
}

"sub" defines a subroutine.  In this case, "respond" is the name of the subroutine, and is the way you call it from the rest of the program.

Subroutines can receive arguments just like Perl programs, but they use another special array "@_".

Subroutines can return a value, using the "return" function.  The function call becomes an expression that evaluates to the return value.

I made the sub more complicated than it needed to be to illustrate that subs can have their own variables.

The variables $name and @full_name are global - they are available to the entire program.  But $first and $last are local to the subroutine respond.  The portion of the program that a variable is available to is called scope.

Scope can get confusing. It is possible to have two variables with the same name but different scope.

In fact, you can declare a variable inside a { } block of an if statement, and the variable will only exist inside that code block.  This might not be terribly useful, but it is important to keep in mind.


Files


for/foreach/while


Regular Expressions


Hashes


Packages/object-oriented


cpan



http://perldoc.perl.org/


http://programming-motherfucker.com/








statements
variables
data representation
expressions
blocks
operators
functions
subroutines
regular expressions
hashes
input
output
files





