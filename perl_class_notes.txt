Hello, Perl
An Absolute Beginner's Guide To Programming With Perl


So you want to learn to program?  Good.  Let's do that.

First things first.


What is programming?

Programming is telling a computer what to do.  We do that by writing programs.  We have to speak a language that the computer understands.  We're going to use Perl.


What is Perl?

Wikipedia: Perl [purl] is a high-level, general-purpose, interpreted, dynamic programming language.

What?  Perl is a kick-ass scripting language.  Meaning programs don't need to be compiled before running.  Perl programs are compiled when you run them ("at runtime"), making it a great cross-platform language.

It has very powerful regular expression implementation (think: search and replace on steroids), which makes it great for processing files.  In fact, this is what what Perl was created to do: parse log files.

It doesn't have strong graphics capabilities (there is a module called PerlTK to create GUIs in Perl) so it is typically run from the command line.


Why do I like Perl?  It's very powerful, yet easy and quick to write and debug, and can be run just about anywhere.  I am usually wanting to analyze, modify, and/or generate files - Perl is ideal for this.


Perl is not well-suited for every task.

If you want to do have interactive graphics, take a look at Processing.

If you want to program embedded devices, take a look at Arduino or Python (on Raspberry Pi).

If you want to do interactive audio, take a look at Pure Data.

But no matter which of these languages you end up using, Perl is a good place to learn.


Why Perl?

Something happened in 1972 - The C Programming Language.  Dennis Ritchie was co-developing the Unix operating system and was unsatisfied with the programming languages available.  So he designed a new programming language, called C.  He and Brian W. Kernighan wrote a book to describe the language, and it is one of the best computer programming books ever written.  It is well-written, clear, and concise (the first edition is only about 120 pages).

C is a simple yet powerful and flexible language.  Most high-level languages that have been introduced since have been largely based on C.  They are dialects of the same language; if you understand C, you can more or less read (and with a little work, write) the others.

So why not start with C?

C has some quirks that make doing simple things more complicated than they need to be (particularly when it comes to string manipulation), and make it easy for you to shoot yourself in the foot.

C is a compiled language, which requires you to install and use a compiler, and slows down the process of writing and running your program.

While C can be portable, platform-specific implementation details can make it a challenge share your program with others.


Perl is very C-like, so you can move to other C-like languages easily.  There is no (separate) compilation step.  And your programs can easily run on other computers.

Perl has a reputation for being intimidating, confusing, and unreadable.  This reputation is not entirely unwarranted (they have contests to see who can create the shortest, least readable Perl program, after all).  But it doesn't have to be that way.

$i=4;$|=@f=map{("!"x$i++)."K$_^\x{0e}"}
"BQI!\\","BQI\\","BQI","BQ","B","";push
@f,reverse@f[1..5];@f=map{join"",undef,
map{chr(ord()-1)}split""}@f;{;$f=shift@
f;print$f;push@f,$f;select undef,undef,
undef,.25;redo;last;exit;print or die;}


Let's get started!


What you need:

A computer
(duh)

Perl
If you have a Mac or Linux machine, it's already there

If you use Windows, download ActivePerl (free) community edition
http://www.activestate.com/activeperl/downloads

Text editor
Any basic text editor will do, but you really want one that is designed for programming

TextWrangler is free for the Mac
BBEdit is worth the $50 if you can afford it and do a lot of this stuff
http://barebones.com/

Notepad++ is free for Windows
http://notepad-plus-plus.org/
TextPad is not free, but is only $27 and is a little more robust
http://www.textpad.com/

You can use command line text editors such as vi or emacs, but GUI text editors are easier.

Terminal Shell
This is a program that lets you send commands to your computer.

Mac: /Applications/Utilities/Terminal

Linux: depends on your distro

Windows: go to start menu and in application box, type cmd.exe

Basic shell commands:

ls (dir) - get directory listing
cd - change directory
pwd - show current working directory


Hello, World

How these things always start: Hello World

Create a text file named 01_hello_world.pl and type:

	print( "Hello, World!\n" );

(The programs for this class are on my github: https://github.com/bangsplat/Perl-Class - but you should type at least this one in by scratch.)

Save the file and from the command line and type:

	perl 01_Hello_World.pl

hit enter and you'll see:

Hello, World!

Congratulations!  You're a programmer.


OK, it might help if you understood what's going on here.


A Perl program is a series of statements, separated by semicolons (;).  The statements are executed in order starting at the top of the file.

This program only has one statement.  It uses the print function to display a string - the text between the double quotes - "Hello, World\n" to the terminal.

What is the "\n"?  It's an escape character.  Escape characters are used to insert special characters into a string.  In this case, the escape character is a newline - it's the same as if pressing the return key on the keyboard.  If you didn't include this, the next command line prompt woudl come right after the output of the program:

$ perl 01_Hello_World.pl
Hello, World!$ perl 01_Hello_World.pl
Hello, World!$

This isn't very pretty and can get confusing.  It's a good practice to make sure you always output a \n at the end of your program's output.

There are lots of escape characters that do similar things.  We'll see others in a bit.

First rule of Perl is there's always a half dozen ways to do things. And chances are, there is always a shorter way to do things.  In fact, you can do the Hello World program on the command line without a file at all:

$ perl -e 'print "Hello, World!\n";'

But most useful programs are too complex to do inline.  So we'll do it the long way.

02_hello_world.pl:

	#!/usr/bin/perl

	# enforce good programming practices
	use strict;
	use warnings;

	print "Hello, World!\n";

We're adding a few things here:

The first line is a comment.  Comments begin with '#'.  Everything from the '#' to the end of the line is ignored by Perl.  Comments can be used for documentation or notes.

#!/usr/bin/perl is a special comment that tells the shell what program to use to execute the script.  Perl doesn't care about this, but Mac and Linux computers do.  Windows, not so much.  But it's good practice to include it anyway.  For Linux or the Mac, it allows you to skip the "perl" part in the command.  But you may have to change the path listed to match where Perl is installed.  On Linux and Mac computers, you can figure out the right path with the which command:

$ which perl
/usr/bin/perl

So if you set the interpreter path correctly, you can run the script like this:

$ ./02_hello_world.pl
Hello, World!

On Linux and Mac OS, you need to make sure the .pl file is set as an executable, which you can do using the chmod command:

$ chmod a+x *.pl

Perl has a module mechanism. Modules are invoked with "use".  In this case, "strict" and "warnings" are pseudo modules.  They warn you when you do things that might be mistakes and enforcing some optional rules that are good programming practices anyway.  After you learn what you're doing, you can omit them, but I recommend you use them to keep from making mistakes and help troubleshoot errors.



What Is A Computer?

You "know" what a computer is.  You're using one now.  You probably own several.  Your cell phone is a computer.  Your car has one.  Your television, cable box, etc., are all essentially computers.  But they don't all look or behave the way you probably think a computer should.

So, what is a computer?  Knowing the answer to this will help us to understand how to program the computer.

A computer is a general-purpose tool.  It does what you tell it to.  (Within reason.)

<picture of computer>

This is what the inside of a computer looks like.  Well, not really, but this shows the essentials.

You need a few things for a computer:

Processor (CPU)
Memory
Input/Output
Clock


The processor is the brains of the computer. It's basically a calculator that follows instructions.

It can only do a few things:

1) read/write data into memory
2) perform operations (such as adding or comparing) on two numbers
3) make decisions based on the result of these things

This is a necessary oversimplification, but it is basically true.

Perl, like any programming language, has built-in functions which does combinations of the above capabilities to accomplish specific things.  "print" is one of these - it outputs a string to the terminal.


Memory is a place where things can be (temporarily) stored, including programs and data.  Traditionally, memory is the vernacular for "RAM" (Random Access Memory) and is volatile - meaning it only persists while the computer is on.  Traditionally, "storage" is what we would call long-term memory - non-volatile storage such as hard drives, floppy disks, and data tapes.  Today, with solid state disks, the difference between memory and storage is being blurred, and more and more computers are using a single store of non-volatile solid state devices for both memory and storage.

Memory and storage may be physically converging, but for reasons of tradition, they are handled differently via controllers that manage the two types of devices.


Input/Output is how we get data into and out of the computer. These take multiple forms - keyboard, monitor, files, printer, camera, microphone, speaker, etc.  We will focus on what we call "Standard I/O" (STDIO) - the keyboard and terminal - and files.


Clock - if the processor is the brains of the computer, the clock is its heart.  The clock is the synchronizer which controls the movement of data.


Data Representation

We don't really care about data.  What we care about is information.  But we need to store that information as data.

Information Theory (The Short Form)

Information is a stream of symbols.  We humans use many symbols

A, B, C, 1, 2, 3, ., !, *, (, ), -, &c.

We use data to represent, store, and transmit symbols.  Information theory is the study of efficient use of data.

Computers only use electricity for data.  Digital computers don't have as many symbols as humans do.  The only have two:

0

and

1

They could have more, and in the future they probably will.

But the way we build comptuers now, they use a voltage (usually 5 volts) to represent 1 and another (usually 0 volts) to represent 0.

(Kind of.)

(Mostly.)

Because there are two symbols, we call this binary (or base 2).  Each symbol is a Binary digIT - or "bit."

10101001 = 8 bits = 1 byte = 2 nibbles

Bits by themselves don't mean anything but we assign values to them or combinations of them.

Humans usually have ten fingers so we count in decimal - or base 10.  Decimal has ten symbols:

0 1 2 3 4 5 6 7 8 9

(Note that I put 0 first.)


How To Count

(Yeah, I know you learned this in kindergarden, but you probably learned wrong.)

Start at 0.

Understand that adding a zero to the left of a number doesn't change it's value.  0 is the same as 00000000.  So pretend there are infinite leading zeros.

Increment the right-most digit by one. (0, 1, 2, 3, 4, 5, 6, 7, 8, 9.)
When you run out of symbols, reset to 0 and increment the digit to the left ("carry the one").

Repeat.

00 01 02 03 04 05 06 07 08 09 10 11 12 &c.

Binary is no different.  We just run out of symbols more frequently.

0000 0001 0010 0011 0100 0101 0110 0111 1000 &c.

We can convert between binary and decimal easily enough.

0 = 0
1 = 1
10 = 2
11 = 3
100 = 4

They don't line up very well.  But say we use 2^4 = 16 symbols - hexadecimal.  We need a few more (a total of 16) symbols:

0 1 2 3 4 5 6 7 8 9 A B C D E F

1 hex digit is exactly 4 bits, or one half a byte (amusingly called a "nibble" back in the day).

0000 = 0 = 0
0001 = 1 = 1
0010 = 2 = 2
0011 = 3 = 3
0100 = 4 = 4
0101 = 5 = 5
0110 = 6 = 6
0111 = 7 = 7
1000 = 8 = 8
1001 = 9 = 9
1010 = 10 = A
1011 = 11 = B
1100 = 12 = C
1101 = 13 = D
1110 = 14 = E
1111 = 15 = F

Because numbers in different bases can look the same, sometimes we add prefixes to identify the base.

Decimal (base 10) 0d
Binary (base 2) 0b
Hexadecimal (base 16) 0x

1 byte = 2^8 = 256 values (0x00 .. 0xFF).

Think of memory as a row of houses.  Each house stores 1 byte.  Each house has it's own address.

Why 8 bits?

It's convenient.  It can store enough values to store every letter, number, punctuation, etc. for any western alphabet (Asian languages require more).

http://asciitable.com

The mapping between byte values and letters/numbers/etc. is called ASCII.  It's entirely arbitrary.  But then, this is true of all data representation (though there may be logic between the choices).

Say we need more than 256 values to represent your data?  No problem - just use more bytes.  Use two (adjacent) houses.

2 houses = 2 bytes = 16 bits = ~32 thousand values = 1 CD sample (or 1 MP3 sample if you don't know what a CD is).

4 houses = 4 bytes = 32 bits = ~4 billion values.

We can represent all positive numbers or both positive and negative numbers this way.  16 bits can be 0..65536 or -16728..16727.  (Zero is treated as a positive number.)  But all are whole numbers.  We call these integers.

If we need fractional numbers, we call that floating point

3.14159
2.5
1.0
1000/1001

Floating point numbers are stored in a complex format that represent the number as an integer and where to put the decimal point.

6.02x10^23 (you might remember this from high school chemistry)

Floating point numbers are typically 32 bits, but there is a double float that is 64 bits.

We can represent anything in binary but we mostly need to worry about a few data types:

characters (single byte values)
string (a sequence of characters)
integers
floating point numbers

Data is stored in memory.  To keep track of where it is in memory, we give the address of the house where it is stored (or the first house if it uses more than one byte) a name.  Think of it as an address book that lists the name of the variable, it's memory address, and what type of variable it is.

(Files are a little different - think of them as one big variable, with a file name instead of an address.  Each byte in the file has its own address inside the file.)


In most programming languages, you have to say what data type a variable is before using it.  This is called "declaring" the variable.  It allocates memory for the variable, setting aside a chunk of memory at a free memory address.

Perl simplifies things for you a bit.  You can actually get away without declaring your variables at all, if you don't use the strict module.  But it's good habit, so we're going to pretend we have to.

What you don't have to do is tell Perl what kind of data you're going to keep in the variable.  Perl is very flexible about that and can deal with all kinds of data, even converting between types as needed.  This is convenient, but you give up some efficiency and speed for this convenience.  So if you find yourself wishing your program were faster, you may want to move to a different language.

Perl only really has one data type, called a scalar.  Scalar variables are identified by a dollar sign at their beginning (like $var).  Scalars are declared with the my keyword:

my $var;

"var" is the name of the variable.  Variable names in Perl are case sensitive, so "var" is not the same as "Var".  Choosing variable names is important - you want them to indicate what the variable is for, but you want to keep it short enough to be manageable.

You can also assign a value to a variable at the time of declaration:

my $var = 1;
my $lastname = "Smith";

(OK, we've introduced a new thing here - the "=" is the assignment operator.  We'll get back to that in a minute.)

There are two other types of variables, but they're just groups of scalars.

Arrays are a series of scalars.  They are identified by a "@" at their beginning (like @addresses).  An array can contain any number of scalars (well, almost any number), and you identify each scalar by number (like @addresses[0] or @addresses[1]).

Just as with counting, you start at zero.  The first item is item number zero.  Which takes a little getting used to.

Hashes are pairs of linked arrays, so you can think of them as an array of arrays.  Hashes are identified by a "%" at their beginning (like %price).  Hashes are basically a rudimentary database.  They are awesome, but they take some learning.

We'll get back to arrays and hashes in a while.

From here on out, we're going to leave out the header part of the program to save space.  The full program will be in the github repository, of course.

03_hello_world.pl

	my $hello_string;
	$hello_string = "Hello, World!\n";
	print( "$hello_string" );

So here, we're declaring a scalar variable named $hello_string, then we're putting the data "Hello, World!\n" into the variable (writing to memory), then we're using the variable in the string we feed to the print function.

When Perl sees a scalar variable name inside double quotes, it "interpolates" the variable - meaning it replaces the variable name with the data stored in the variable.  So,

	print "$hello_string";

is functionally the same as 

	print "Hello, World!\n";

The value of a variable can change (hence the name, variable).  So you can do this:

	my $hello_string;

	$hello_string = "derp";
	$hello_string = "Hello, World!\n";

	print "$hello_string";

After the first assignment, $hello_string contains "derp".  The second replaces the string "derp" with "Hello, World!\n".

The "=" is the assignment operator.  It sets the thing to the left of the operator (our variable in this case) to the value of the thing to the right of the operator (our string in this case).

Just about anything can happen to the right of the assignment operator (or, indeed, most operators).  Including another variable:

	my $a = "Hello, World!\n";
	my $hello_string = $a;

04_variables.pl

	my $my_string;	# declare a variable named $my_string
	my $another_string = "blah blah blah";	# declare a variable and set it's value
	my ( $a, $b );	# declare two variables at once

	$my_string = "Hello, World!\n";	# set value of $my_string

	$another_string = $my_string;	# set value of $another_string to be same as $my_string

	$a = $b = 1;					# set both $a and $b to 1;

	print "\$my_string: $my_string\n";
	print "\$another_string: $another_string\n";
	print "\$a: $a\n";
	print "\$b: $b\n";

When you run this, you see:

	$my_string: Hello, World!

	$another_string: Hello, World!

	$a: 1
	$b: 1

Pop quiz: Why the blank lines after the Hello, World! strings?


Declaring variables

You declare a variable using the "my" keyword.  You can declare more than one variable with each "my" by putting them in parenthesis.  You can declare a variable and set it's value by using the assignment operator.


Setting variables

You set the value of a variable with the assignment operator ("=").

You can use a string, a number, or another variable to set the value of a variable.

Because assignment operators work from right to left, you can assign a variable and use the value of that variable to set another variable.

You should always set the value of a variable before you use it.  The warnings module will warn you if you do not.  In theory, every unassigned variable has a special value called undef, but you may find things don't work predictably if you don't assign values before using variables.


Variables and strings

Text in between double quote marks are a string.  If you put a scalar variable in a string, Perl substitutes the variable name for the contents of the variable.

But what if we want to put the name of the variable in a string?  You have to "escape" the "$" character by putting a backslash in front of it ("\$").  This makes perl actually put in a dollar sign character in the string instead of using it for a variable name.  This also works for other special characters like double quotes and such.


Functions

Functions are like little programs that you run inside a program.  They have inputs (parameters) and outputs (return values).  Their output can be assigned to a variable or used as a parameter for another function.

Function names, like variable names, are case-sensitive.

Perl has many built-in functions.  Print is a function, for example.

You can also define your own functions with the sub keyword.  (sub is short for subroutine, which is what they are called in BASIC.)

In most programming languages, functions are called by using their name followed by parenthesis, with any parameters inside the parenthesis, separated by commas.

	function( a, b, c );

You can do this in Perl, too.  Or not.  Perl doesn't really care.  Perl is like the Honey Badger of programming languages.

It comes down to programming style.  I personally use parenthesis a lot - I think they help keep the code readable.  But you don't have to.

05_functions.pl

	my $my_string = "blah blah blah";
	my $string_length = length( $my_string );

	print( $my_string . "\n" );		# classic function form
	print $my_string . "\n";		# look ma, no parenthesis!

	print "\"$my_string\" is " . length( $my_string ) . " characters long\n";
	print "\"$my_string\" is $string_length characters long\n";

	my_function( $my_string );

	my $result = how_long( $my_string );
	print "\"$my_string\" is $result characters long\n";
	print "\"$my_string\" is " . how_long( $my_string ) . " characters long\n";

	$result = my_function();
	print "my_function returned $result\n";

	sub my_function {
		my $param = @_[0];
		print "You said \"$param\"\n";
	}

	sub how_long {
		my $param = $_[0];
		return length( $param );
	}

Output of the program:

	blah blah blah
	blah blah blah
	"blah blah blah" is 14 characters long
	"blah blah blah" is 14 characters long
	You said "blah blah blah"
	"blah blah blah" is 14 characters long
	"blah blah blah" is 14 characters long
	You said ""
	my_function returned 1

OK, lots of new things here.

"." is an operavtor.  It concatenates two strings together.  So you can add a newline character to the end of another string.

We're also using the escaped double quote to put a double quote character inside a string.

length() is a built-in function that returns an integer - the length of a string.  You can assign it's output to a variable or you can use it as the parameter for another function such as print().

There are two defined functions here: my_function() and how_long().  They use the sub keyword and have a code block surrounded by curly braces to define the function.  my_function() does not return a value.  Well, as we see it technically does.  Any function without an explicit return value simply returns "1" indicating success.

how_long() explicitly returns the length of a string passed to it.  This is kind of pointless since we have the built-in length() function, but we could be counting the number of spaces or uppercase letters of something else instead.

A function's return value is set using the return() function.

Also notice this:

	my $param = @_[0];

This is how we get the parameter passed to the function.  @_ is an array.  @_[0] is the first item in the array (remember, start with zero).  @_ is a special built-in variable you don't need to declare because it's built-in to Perl.  Perl takes all of the parameters passed to a function and puts them into the array @_.  The first parameter is in the first item of the array, the second in the second, etc.

Notice in one sub I use @_[0] and the other $_[0].  They both work.  The array is called @_, but when we precede an array with the scalar variable type, Perl converts the array value to a scalar.  However, since we're putting @_[0] into a scalar, Perl figures we want it converted and does it anyhow.  Technically, $_[0] is more correct.  But Perl is generally pretty smart about what you want to do.

If you find yourself doing the same thing over and over again in your program, consider making it a function.


Scope

Notice that I declare $param in both subs.  Normally with use strict on, declaring a variable twice would cause an error.  Why does this work?

Variables have a "scope" which defines where that variable is valid and can be used.  When you declare a variable inside a code block (a chunk of code between curly braces), the variable is created at the point where it is declared, and it is destroyed at the end of the code block.  The variable is said to have local scope.

Variables declared outside of any code blocks are said to have global scope and are available everywhere in the program.

You can declare a variable inside a code block with the same name as a global variable.  It essentially replaces (while in scope) the global variable.

Scope can be confusing.  And re-using variable names can increase the confusion, so keep it to a minimum.  There are a few variables I will use in multiple scopes, such as function parameters, like above.  But it's dangerous and the results can be unpredictable.  So just don't.


Operators

We've seen a couple operators so far.  But "=" and "." seem to do different things.  But they're both operators.  And they have similar properties.

Operators do things to bits of memory (variables or output of functions), such as addition. There are other operators that mostly do variations on addition (again, this is a bit of an oversimplification).

06_operators.pl

	my ( $a, $b, $c );
	my $my_string = "foo";

	$a = 2;
	$b = 5;
	$c = 2 + 2;
	print "result is $c\n";
	$c = $a + $b;
	print "result is $c\n";
	$c = $a * $b;
	print "result is $c\n";
	$c += $a;
	print "result is $c\n";
	$c *= $b;
	print "result is $c\n";
	$c++;

	if ( $c >= 60 ) {
		print "\$c is greater than or equal to 60\n";
	} else {
		print "\$c is less than 60\n";
	}

	print "\$c is $c\n";
	if ( $c-- == 60 ) { print "\$c is exactly 60\n"; }
	else { print "\$c is NOT 60\n"; }

	print "\$c is $c\n";
	if ( --$c == 60 ) { print "\$c is exactly 60\n"; }
	else { print "\$c is NOT 60\n"; }

	if ( $c != 0 ) { print "\$c is not zero\n"; }
	print "\$c is $c\n";

	print "$c" . " " x 5 . "\n";
	print "$c " x 5 . "\n";

	if ( $my_string = "foo" ) { print "\$my_string = \"foo\"\n"; }
	if ( $my_string = "bar" ) { print "\$my_string = \"bar\"\n"; }
	if ( $my_string == "foo" ) { print "\$my_string == \"foo\"\n"; }
	if ( $my_string == "bar" ) { print "\$my_string == \"bar\"\n"; }
	if ( $my_string eq "foo" ) { print "\$my_string eq \"foo\"\n"; }
	if ( $my_string eq "bar" ) { print "\$my_string eq \"bar\"\n"; }
	if ( $my_string ne "foo" ) { print "\$my_string ne \"foo\"\n"; }
	if ( $my_string ne "bar" ) { print "\$my_string ne \"bar\"\n"; }
	print "$my_string\n";

Output:

	result is 4
	result is 7
	result is 10
	result is 12
	result is 60
	$c is greater than or equal to 60
	$c is 61
	$c is NOT 60
	$c is 60
	$c is NOT 60
	$c is not zero
	$c is 59
	59     
	59 59 59 59 59 
	$my_string = "foo"
	$my_string = "bar"
	$my_string == "foo"
	$my_string == "bar"
	$my_string eq "bar"
	$my_string ne "foo"
	bar

OK.  Lots of operators.  Perl has lots of operators.  It's not important that you learn all of them right away, but here are some examples:

= is the assignment operator - makes the item on the left equal to the item on the right.
+ is addition - adds the left and right together
- / * other math operators
+= adds the right to the left and puts the result in the left, unlike + which just evaluates to the result and needs to be used with an operator or as a parameter.
-= *= /= same thing but for other math functions.
++ increment operator - adds 1.
-- decrement operator - subtracts 1.
== equality operator - checks for equality of the left and right and evaluates to 1 if they match and 0 if they do not.
> greater than comparison operator - evaluates to 1 if left is greater than right.
< less than comaprison operator - evaluates to 1 if left is less than right.
>= greater than or equal to comparison operator - evaluates to 1 if left is greater than or equal to the right, 0 otherwise.
<= less than or equal to comaprison operator.
!= inequality operator - evaluates to 1 if left and right are not equal, 0 otherwise.
x repetition operator repeats the left by the number on the right
. concatenation operator - evaluates to the left and right concatenated together (does not modify the left)
.= concatenation operator - modifies the left by concatenating the right.
eq string equality operator - compares left and right as strings, evaluates to 1 if they are equal, 0 otherwise.
ne string inequality operator - opposite of eq.
lt string less than operator - compares left and right and evaluates to 1 if left is stringwise less then right.
gt string greater than operator - compares left and right and evaluates to 1 if left is stringwise greater then right.

We are also doing conditional branching with if statements.

if(){}else{} executes the code block if the expression in the parenthesis evaluates to 1.  Otherwise it executes the else code block.

Most of these operators are pretty straightforward.  But some get confusing.

+ vs +=
- vs -=

+, -, *, and / are standard arithmetic operators.  Like '.' they operate on the thing on the left and the thing on the right, and return the result.  But they leave both things (left and right) unchanged.

+=, -=, *=, and /= work the same, but they modify the thing on the left to contain the result.  Think of $a += $b to mean "add $b to $a".  Whereas $a + $b is "what is $a plus $b?".


= vs ==

A very common mistake is trying to use = to test for equality.

	my $a = 1;
	if ( $a = 2 ) { print "$a\n"; }

Here $a starts out as 1, but in the second line where we want to test to see if it is 2, we are actually assigning it to be 2.

The assignment operator evaluates to 1 because the assignment was successful, so it prints the value of $a, and it's different from what we first assigned to it.

Instead we want to use == to test the value of $a:

	my $a = 1;
	if ( $a == 2 ) { print "$a\n"; }

In this case, $a is not equal to 2 so it does not print the value.


== vs eq

Perl tries to convert your variables for you, but sometimes it doesn't work out right.

Short story - use ==, !=, >, <, >=, <= to compare numbers and use eq, ne, lt, gt, lte, gte to comapre strings.  That way Perl knows what you're talking about.

If you use the wrong one (say you use == to compare strings) the result might not be what you expected.


++ and --

Increment and decrement operators can come before or after a variable name.  Where they are placed determines when they increment and decrement.  When before, the increment/decrement happens before the expression is evaluated.  When after, it happens after the expression is evaluated.  This is very important when it comes to comaprisons.

	my $a = 1;
	if ( $a++ == 1 ) { print "hooray!\n";}
	if ( $a++ == 1 ) { print "hooray!\n";}

The first if statement tests true because $a is 1 to start with.  But after the if() test, $a is incremented to be 2.  The second tests false because $a is no longer 1.  After the second if() test, $a is incremented to 3.

	my $a = 1;
	if ( ++$a == 1 ) { print "hooray!\n";}
	if ( ++$a == 1 ) { print "hooray!\n";}

In this case, $a is incremented to 2 before the equality test in the first if() statement, so it tests false.  $a is 3 for the second if() so it tests false as well.


Precedence and Associvity

What order are operators performed in?  There is an order in which operators are performed.  For math operators, it's generally the same as you were taught in Algebra.  * and / are done before + and -.

And if you have more than one operator with the same precedence in a row, they are mostly left associative (that is, they are done in left-to-right order).  Mostly.  There are some that are right associative.

There is a complete list of operator precedence and associativity at http://perldoc.perl.org/perlop.html.

If you can't keep track and you need things to be done in a particular order, you can control it by adding parenthesis around them.  And parenthesis can be nested (that is you can (or is it may?) parenthesis inside parenthesis).  Operators in the inner-most parenthesis are performed first.

07_precedence.pl

	my $result;
	$result = 2 + 4 * 5;	#	== 22
	$result = (2 + 4) * 5;	#	== 30
	$result = 8 - 4 - 2;	#	== 2
	$result = 8 - (4 - 2);	#	== 6


Flow Control

Perl is a procedural programming language.  Each program starts at the top and proceeds down line by line (or rather, statement by statement).  But if it always does exactly the same thing, it isn't that useful and you wouldn't need to run it more than once.  So we have what we call flow control to change the order in which we do things.

Flow control is managed with two things: conditional operators and subroutines.

We've seen examples of each of these now.  Subroutines are the functions defined with the sub keyword.

The if() statement was an example of a conditional operator.  But we used a simple version.  It can get complicated.  Real complicated.


#####



tests
if() {} elsif() {} else {};


loops

for
while
foreach



input




files




regular expressions







Variables

One convenient thing about Perl is you don't have to worry too much about how your data is represented in memory.  Some languages like C have multiple variable types which store data in different ways.  Perl only really has one type - called a scalar.  There are also arrays, which are a collection of scalars.  There is a special type of array called a hash, which is one of the great features of Perl.

Scalar variables start with a '$'.  Arrays start with an '@'.  Hashes start with a '%'.

Perl will convert between different types of variables for you as needed. This is convenient, but has the downside that Perl may not be as efficient or optimized as a result. Perl isn't necessarily the best choice for resource-constrained applications.

You have to tell Perl about your variables, or "declare" them.  You use the "my" keyword to declare variables.  A single "my" can declare multiple variables when enclosed in parenthesis:

my $variable;
my ( $foo, $bar );

You put data into or read data from a variable with the '=' assignment operator:

$variable = "blah";
$foo = $variable;
$bar = 42;

The operation depends on which side of the '=' the variable is on.  Read on the right, write on the left.

Perl has a bunch of specialized variables, like $_, $1, @ARGV (and many more).  You cannot name a variable the same as one of these special variables, but you can use any alphanumeric string as a variable name.  Variable names, like everything in Perl, are case-sensitive.


Expressions

A variable isn't the only thing that can be on the right of the equal sign.  A variable used this way is one form of an expression, and any expression can be used on the right side of the equal sign.

Other types of expressions are strings ("Hello, World!\n"), arithmetic (1+1), conditional operators, and the output of functions (built-in or user defined).

We illustrate the various types of expressions in 06_expressions.pl:

#!/usr/bin/perl
use strict;

my $helloworld = "Hello, World!";     # assigning string at time of delcaration
my ( $i, $j );
my $result;
my ( $foo, $bar );

$i = 0;                               # assigning a number to a scalar
$bar = $i + 42;                       # assigning the result of an arithmetic expression
$foo = $bar;                          # assigning the value of a variable
$result = print "$helloworld\n";      # assigning the output of a function
$j = ( $i == 0 );                     # assigning the result of a conditional operator

print "The result of the print function is: \"$result\"\n";print "\$i: \"$i\"\n";
print "\$j: \"$j\"\n";
print "\$foo: \"$foo\"\n";
print "\$bar: \"$bar\"\n";


Which results in this output:

$ perl 06_expressions.pl
Hello, World!
The result of the print function is: "1"
$i: "0"
$j: "1"
$foo: "42"
$bar: "42"

As mentioned before, we can declare more than one variable with a single "my" by making them a list and enclosing them in parenthesis.

Next we have some examples of different types of expressions being assigned to variables.

$i = 0; assigns the numeric zero into the variable $1.

$bar = $i + 42; takes the value of $i (0) and adds 42, putting the result in $bar.

$foo = $bar; takes the value of $bar (42) and puts it in $foo.

$result = print "$helloworld\n"; calls the print function and puts the result into $result. The print function returns true if print was successful. A Boolean true in Perl  is represented by a numeric 1.  A Boolean false is anything other than a 1, usually a special value called undef, or undefined. Print almost always succeeds, so this put 1 into $result.

$j = ( $i == 0 ); introduces a new operator, the equality test "==".  It test the value of the variable on the left ($i) against the expression on the right (0) and if they are equal, the result is true (or 1).  If they are not equal, the result is undef.

One of the most common Perl mistakes is to use the assignment operator "=" and the equality operator "==".  If we did the wrong thing:

$j = ( $i = 0 );

It would not generate an error, but the result would be very different.  It would have assigned the numeric value zero to $i and then assigned the value of $i (0) to $j.  So instead of $j being at set of $i being true, we would have inadvertently assigned the wrong value to both $i and $j.


One of the nice things about Perl is it tries its best to convert different types of data for you on the fly.  When a scalar variable is used in a string expression, the value of that variable is converted into a string and substituted.  So when we did:

print "\$i: \"$i\"\n";

We have a couple new escape characters here: \$ and \".  Both of these are used to insert characters into a string that would otherwise be interpreted as the start of a variable name or a double quote character.

So $i (the second one - since the \$ puts an actual '$' character into the string, the first \$i is actually the string "$i" rather than the variable) contains a numeric zero, which is turned into the string "0" and printed.

If the variable already contains a string, the conversion is easier:

$result = print "$helloworld\n";

The variable $helloworld, which contains the string "Hello, World!", is simply replaced by the string.


Input

These programs all do the same exact thing every time, which is kind of pointless.  You don't want to have to write a new program each time you want to do something different, so we need a way to get external information to the program.  A common way to do this in Perl is with command line arguments.  03_echo.pl:

#!/usr/bin/perl
use strict;

print "@ARGV\n";

Arrays start with '@', so $ARGV is an array.  It's a special variable in Perl - it contains the command line arguments.  So now we can type some additional things on the command line:

$ perl 03_echo.pl these are arguments
these are arguments

We see what happens to an array in a string context?  It gets converted to a string, in the nicest way possible.

If we did this:

print @ARGV;

we would get the following output:

$ perl -e 'print @ARGV;' these are argumentsthesearearguments
Besides the lack of a \n at the end, notice the lack of spaces. Perl splits up arguments amongst the elements of the array @ARGV. This is helpful in this case, so we can get the arguments individually. To access the individual elements of an Array, we use square brackets to identify which:

04_echo.pl

#!/usr/bin/perl
use strict;

if ( $ARGV[0] eq undef ) {
     print "Please type your name\n";
} else {
     print "Hello, @ARGV[0], I see your last name is @ARGV[1]\n";
}

So now if you type your name as arguments to 04_echo.pl, you get the following:

$ perl 04_echo.pl Theron Trowbridge
Hello, Theron, I see your last name is Trowbridge

But what happens if you don't type anything?

$ perl 04_echo.pl
Please type your name

Some changes here.  First, since what we're expecting to be typed is a string, we are using the scalar context of the array @ARGV.  $ARGV[0] means the first item of @ARGV in scalar (string) context.  Putting @ARGV[0] or @ARGV[1] inside a double-quoted string automatically converts the array item to scalar context.  We could have used $ARGV[0] and $ARGV[1] as well.

$ARGV[0] means the first item?  Yeah - in Perl like most programming languages, you start counting at 0 (zero).  I know this can be confusing at first.  Get used to it, and even if you are in a position that you could start counting from 1, start with 0.

We're using "eq" instead of "==" to compare the first argument.  "==" is a numeric equality operator, but "eq" is a string equality operator.  Again, we're expecting strings, so we want to use "eq".  "undef" is the keyword that means undefined.  So if the first argument is empty, the expression is true, so the first code block is executed (print "Please type your name\n";).  If something was typed, the expression will be false, so it executes the else code block (print "Hello, @ARGV[0], I see your last name is @ARGV[1]\n";).

You can check for multiple if values

if ( $a eq "a" ) {
     ;
} elsif ( $a eq "b" ) {
     ;
} else {
     ;
}

You use if for the first test, each of the elsif are evaluated if the preceding tests are false.  Evaluation stops when one of the tests is true.  If none of the tests are true, the else{} block is executed.

You can make this work with the numerical equality operator if you really want to:

if ( @ARGV[0] == "" )

"" is an empty string, which a numerical value of zero, or null, which is the same as not typing anything.  But this is a special case, and you can't use "==" (easily) to test if a particular string was typed, so it's best to get in the habit of using "eq" for strings.

OK, this is all great, but the program says "type your name" so why can't you just type your name?  That's another form of input - user interactivity.

Try 07_echo_name.pl

#!/usr/bin/perl
use strict;

my ( $name, @full_name );

if ( $ARGV[0] eq undef ) {
     print "Please type your name\n";
     chomp( $name = <STDIN> );
     @full_name = split( /\s+/, $name );
     print "Hello, @full_name[0], I see your last name is @full_name[1]\n";
} else {
     print "Hello, @ARGV[0], I see your last name is @ARGV[1]\n";
}

Now, you can type your name as arguments to the script or you can respond when it says type your name:

$ perl 07_echo_name.pl
Please type your name
Theron Trowbridge
Hello, Theron, I see your last name is Trowbridge

<STDIN> is in input operator.  Specifically it's a line input operator that reads from the keyboard.  You can read from a file in a similar manner.  But we'll get to that in a bit.

chomp() is a function that removes extraneous whitespace from a string.  We use it in this case because otherwise the return that you press after typing your name will get included in the input.

We could make this longer if we wanted:

$name = <STDIN>;
chomp( $name );

But the tendency in Perl is to combine lines when possible.  It's easy to get carried away with this and render code unreadable, which gives Perl it's reputation for being indeciperable.  So try not to get carried away.

Notice that we have two very similar lines that differ only in the array items being used?  One repeated line is not that big a deal, but it's easy to have large duplicate blocks of code, which makes your code bigger and less efficient.  And if you make a change to it in one place but not in all, you can have unexpected results.

Any time you have common code you want to be able to call from multiple points in your code, you can create a subroutine.

08_echo_name:

#!/usr/bin/perl
use strict;

my ( $name, @full_name );

if ( $ARGV[0] eq undef ) {
     print "Please type your name\n";
     chomp( $name = <STDIN> );
     @full_name = split( /\s+/, $name );
     print( respond( $full_name[0], $full_name[1] ) );
} else {
     print( respond( $ARGV[0], $ARGV[1] ) );
}

sub respond {
     my $first = @_[0];
     my $last = @_[1];
     return( "Hello, $first, I see your last name is $last\n" );
}

"sub" defines a subroutine.  In this case, "respond" is the name of the subroutine, and is the way you call it from the rest of the program.

Subroutines can receive arguments just like Perl programs, but they use another special array "@_".

Subroutines can return a value, using the "return" function.  The function call becomes an expression that evaluates to the return value.

I made the sub more complicated than it needed to be to illustrate that subs can have their own variables.

The variables $name and @full_name are global - they are available to the entire program.  But $first and $last are local to the subroutine respond.  The portion of the program that a variable is available to is called scope.

Scope can get confusing. It is possible to have two variables with the same name but different scope.

In fact, you can declare a variable inside a { } block of an if statement, and the variable will only exist inside that code block.  This might not be terribly useful, but it is important to keep in mind.


Files


for/foreach/while


Regular Expressions


Hashes


Packages/object-oriented


cpan



http://perldoc.perl.org/


http://programming-motherfucker.com/








statements
variables
data representation
expressions
blocks
operators
functions
subroutines
regular expressions
hashes
input
output
files





