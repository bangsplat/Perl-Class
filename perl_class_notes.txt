Hello, Perl
An Absolute Beginner's Guide To Programming With Perl


So you want to learn to program?  Good.  Let's do that.

First things first.


What is programming?

Programming is telling a computer what to do.  We do that by writing programs.  We have to speak a language that the computer understands.  We're going to use Perl.


What is Perl?

Wikipedia: Perl [purl] is a high-level, general-purpose, interpreted, dynamic programming language.

What?  Perl is a kick-ass scripting language.  Meaning programs don't need to be compiled before running.  Perl programs are compiled when you run them ("at runtime"), making it a great cross-platform language.

It has very powerful regular expression implementation (think: search and replace on steroids), which makes it great for processing files.  In fact, this is what what Perl was created to do: parse log files.

It doesn't have strong graphics capabilities (there is a module called PerlTK to create GUIs in Perl) so it is typically run from the command line.


Why do I like Perl?  It's very powerful, yet easy and quick to write and debug, and can be run just about anywhere.  I am usually wanting to analyze, modify, and/or generate files - Perl is ideal for this.


Perl is not well-suited for every task.

If you want to do have interactive graphics, take a look at Processing.

If you want to program embedded devices, take a look at Arduino or Python (on Raspberry Pi).

If you want to do interactive audio, take a look at Pure Data.

But no matter which of these languages you end up using, Perl is a good place to learn.


Why Perl?

Something happened in 1972 - The C Programming Language.  Dennis Ritchie was co-developing the Unix operating system and was unsatisfied with the programming languages available.  So he designed a new programming language, called C.  He and Brian W. Kernighan wrote a book to describe the language, and it is one of the best computer programming books ever written.  It is well-written, clear, and concise (the first edition is only about 120 pages).

C is a simple yet powerful and flexible language.  Most high-level languages that have been introduced since have been largely based on C.  They are dialects of the same language; if you understand C, you can more or less read (and with a little work, write) the others.

So why not start with C?

C has some quirks that make doing simple things more complicated than they need to be (particularly when it comes to string manipulation), and make it easy for you to shoot yourself in the foot.

C is a compiled language, which requires you to install and use a compiler, and slows down the process of writing and running your program.

While C can be portable, platform-specific implementation details can make it a challenge share your program with others.


Perl is very C-like, so you can move to other C-like languages easily.  There is no (separate) compilation step.  And your programs can easily run on other computers.

Perl has a reputation for being intimidating, confusing, and unreadable.  This reputation is not entirely unwarranted (they have contests to see who can create the shortest, least readable Perl program, after all).  But it doesn't have to be that way.

$i=4;$|=@f=map{("!"x$i++)."K$_^\x{0e}"}
"BQI!\\","BQI\\","BQI","BQ","B","";push
@f,reverse@f[1..5];@f=map{join"",undef,
map{chr(ord()-1)}split""}@f;{;$f=shift@
f;print$f;push@f,$f;select undef,undef,
undef,.25;redo;last;exit;print or die;}


Let's get started!


What you need:

A computer
(duh)

Perl
If you have a Mac or Linux machine, it's already there

If you use Windows, download ActivePerl (free) community edition
http://www.activestate.com/activeperl/downloads

Text editor
Any basic text editor will do, but you really want one that is designed for programming

TextWrangler is free for the Mac
BBEdit is worth the $50 if you can afford it and do a lot of this stuff
http://barebones.com/

Notepad++ is free for Windows
http://notepad-plus-plus.org/
TextPad is not free, but is only $27 and is a little more robust
http://www.textpad.com/

You can use command line text editors such as vi or emacs, but GUI text editors are easier.

Terminal Shell
This is a program that lets you send commands to your computer.

Mac: /Applications/Utilities/Terminal

Linux: depends on your distro

Windows: go to start menu and in application box, type cmd.exe

Basic shell commands:

ls (dir) - get directory listing
cd - change directory
pwd - show current working directory


Hello, World

How these things always start: Hello World

Create a text file named 01_hello_world.pl and type:

	print( "Hello, World!\n" );

(The programs for this class are on my github: https://github.com/bangsplat/Perl-Class - but you should type at least this one in by scratch.)

Save the file and from the command line and type:

	perl 01_Hello_World.pl

hit enter and you'll see:

Hello, World!

Congratulations!  You're a programmer.


OK, it might help if you understood what's going on here.


A Perl program is a series of statements, separated by semicolons (;).  The statements are executed in order starting at the top of the file.

This program only has one statement.  It uses the print function to display a string - the text between the double quotes - "Hello, World\n" to the terminal.

What is the "\n"?  It's an escape character.  Escape characters are used to insert special characters into a string.  In this case, the escape character is a newline - it's the same as if pressing the return key on the keyboard.  If you didn't include this, the next command line prompt woudl come right after the output of the program:

$ perl 01_Hello_World.pl
Hello, World!$ perl 01_Hello_World.pl
Hello, World!$

This isn't very pretty and can get confusing.  It's a good practice to make sure you always output a \n at the end of your program's output.

There are lots of escape characters that do similar things.  We'll see others in a bit.

First rule of Perl is there's always a half dozen ways to do things. And chances are, there is always a shorter way to do things.  In fact, you can do the Hello World program on the command line without a file at all:

$ perl -e 'print "Hello, World!\n";'

But most useful programs are too complex to do inline.  So we'll do it the long way.

02_hello_world.pl:

	#!/usr/bin/perl

	# enforce good programming practices
	use strict;
	use warnings;

	print "Hello, World!\n";

We're adding a few things here:

The first line is a comment.  Comments begin with '#'.  Everything from the '#' to the end of the line is ignored by Perl.  Comments can be used for documentation or notes.

#!/usr/bin/perl is a special comment that tells the shell what program to use to execute the script.  Perl doesn't care about this, but Mac and Linux computers do.  Windows, not so much.  But it's good practice to include it anyway.  For Linux or the Mac, it allows you to skip the "perl" part in the command.  But you may have to change the path listed to match where Perl is installed.  On Linux and Mac computers, you can figure out the right path with the which command:

$ which perl
/usr/bin/perl

So if you set the interpreter path correctly, you can run the script like this:

$ ./02_hello_world.pl
Hello, World!

On Linux and Mac OS, you need to make sure the .pl file is set as an executable, which you can do using the chmod command:

$ chmod a+x *.pl

Perl has a module mechanism. Modules are invoked with "use".  In this case, "strict" and "warnings" are pseudo modules.  They warn you when you do things that might be mistakes and enforcing some optional rules that are good programming practices anyway.  After you learn what you're doing, you can omit them, but I recommend you use them to keep from making mistakes and help troubleshoot errors.



What Is A Computer?

You "know" what a computer is.  You're using one now.  You probably own several.  Your cell phone is a computer.  Your car has one.  Your television, cable box, etc., are all essentially computers.  But they don't all look or behave the way you probably think a computer should.

So, what is a computer?  Knowing the answer to this will help us to understand how to program the computer.

A computer is a general-purpose tool.  It does what you tell it to.  (Within reason.)

<picture of computer>

This is what the inside of a computer looks like.  Well, not really, but this shows the essentials.

You need a few things for a computer:

Processor (CPU)
Memory
Input/Output
Clock


The processor is the brains of the computer. It's basically a calculator that follows instructions.

It can only do a few things:

1) read/write data into memory
2) perform operations (such as adding or comparing) on two numbers
3) make decisions based on the result of these things

This is a necessary oversimplification, but it is basically true.

Perl, like any programming language, has built-in functions which does combinations of the above capabilities to accomplish specific things.  "print" is one of these - it outputs a string to the terminal.


Memory is a place where things can be (temporarily) stored, including programs and data.  Traditionally, memory is the vernacular for "RAM" (Random Access Memory) and is volatile - meaning it only persists while the computer is on.  Traditionally, "storage" is what we would call long-term memory - non-volatile storage such as hard drives, floppy disks, and data tapes.  Today, with solid state disks, the difference between memory and storage is being blurred, and more and more computers are using a single store of non-volatile solid state devices for both memory and storage.

Memory and storage may be physically converging, but for reasons of tradition, they are handled differently via controllers that manage the two types of devices.


Input/Output is how we get data into and out of the computer. These take multiple forms - keyboard, monitor, files, printer, camera, microphone, speaker, etc.  We will focus on what we call "Standard I/O" (STDIO) - the keyboard and terminal - and files.


Clock - if the processor is the brains of the computer, the clock is its heart.  The clock is the synchronizer which controls the movement of data.


Data Representation

We don't really care about data.  What we care about is information.  But we need to store that information as data.

Information Theory (The Short Form)

Information is a stream of symbols.  We humans use many symbols

A, B, C, 1, 2, 3, ., !, *, (, ), -, &c.

We use data to represent, store, and transmit symbols.  Information theory is the study of efficient use of data.

Computers only use electricity for data.  Digital computers don't have as many symbols as humans do.  The only have two:

0

and

1

They could have more, and in the future they probably will.

But the way we build comptuers now, they use a voltage (usually 5 volts) to represent 1 and another (usually 0 volts) to represent 0.

(Kind of.)

(Mostly.)

Because there are two symbols, we call this binary (or base 2).  Each symbol is a Binary digIT - or "bit."

10101001 = 8 bits = 1 byte = 2 nibbles

Bits by themselves don't mean anything but we assign values to them or combinations of them.

Humans usually have ten fingers so we count in decimal - or base 10.  Decimal has ten symbols:

0 1 2 3 4 5 6 7 8 9

(Note that I put 0 first.)


How To Count

(Yeah, I know you learned this in kindergarden, but you probably learned wrong.)

Start at 0.

Understand that adding a zero to the left of a number doesn't change it's value.  0 is the same as 00000000.  So pretend there are infinite leading zeros.

Increment the right-most digit by one. (0, 1, 2, 3, 4, 5, 6, 7, 8, 9.)
When you run out of symbols, reset to 0 and increment the digit to the left ("carry the one").

Repeat.

00 01 02 03 04 05 06 07 08 09 10 11 12 &c.

Binary is no different.  We just run out of symbols more frequently.

0000 0001 0010 0011 0100 0101 0110 0111 1000 &c.

We can convert between binary and decimal easily enough.

0 = 0
1 = 1
10 = 2
11 = 3
100 = 4

They don't line up very well.  But say we use 2^4 = 16 symbols - hexadecimal.  We need a few more (a total of 16) symbols:

0 1 2 3 4 5 6 7 8 9 A B C D E F

1 hex digit is exactly 4 bits, or one half a byte (amusingly called a "nibble" back in the day).

0000 = 0 = 0
0001 = 1 = 1
0010 = 2 = 2
0011 = 3 = 3
0100 = 4 = 4
0101 = 5 = 5
0110 = 6 = 6
0111 = 7 = 7
1000 = 8 = 8
1001 = 9 = 9
1010 = 10 = A
1011 = 11 = B
1100 = 12 = C
1101 = 13 = D
1110 = 14 = E
1111 = 15 = F

Because numbers in different bases can look the same, sometimes we add prefixes to identify the base.

Decimal (base 10) 0d
Binary (base 2) 0b
Hexadecimal (base 16) 0x

1 byte = 2^8 = 256 values (0x00 .. 0xFF).

Think of memory as a row of houses.  Each house stores 1 byte.  Each house has it's own address.

Why 8 bits?

It's convenient.  It can store enough values to store every letter, number, punctuation, etc. for any western alphabet (Asian languages require more).

http://asciitable.com

The mapping between byte values and letters/numbers/etc. is called ASCII.  It's entirely arbitrary.  But then, this is true of all data representation (though there may be logic between the choices).

Say we need more than 256 values to represent your data?  No problem - just use more bytes.  Use two (adjacent) houses.

2 houses = 2 bytes = 16 bits = ~32 thousand values = 1 CD sample (or 1 MP3 sample if you don't know what a CD is).

4 houses = 4 bytes = 32 bits = ~4 billion values.

We can represent all positive numbers or both positive and negative numbers this way.  16 bits can be 0..65536 or -16728..16727.  (Zero is treated as a positive number.)  But all are whole numbers.  We call these integers.

If we need fractional numbers, we call that floating point

3.14159
2.5
1.0
1000/1001

Floating point numbers are stored in a complex format that represent the number as an integer and where to put the decimal point.

6.02x10^23 (you might remember this from high school chemistry)

Floating point numbers are typically 32 bits, but there is a double float that is 64 bits.

We can represent anything in binary but we mostly need to worry about a few data types:

characters (single byte values)
string (a sequence of characters)
integers
floating point numbers

Data is stored in memory.  To keep track of where it is in memory, we give the address of the house where it is stored (or the first house if it uses more than one byte) a name.  Think of it as an address book that lists the name of the variable, it's memory address, and what type of variable it is.

(Files are a little different - think of them as one big variable, with a file name instead of an address.  Each byte in the file has its own address inside the file.)


In most programming languages, you have to say what data type a variable is before using it.  This is called "declaring" the variable.  It allocates memory for the variable, setting aside a chunk of memory at a free memory address.

Perl simplifies things for you a bit.  You can actually get away without declaring your variables at all, if you don't use the strict module.  But it's good habit, so we're going to pretend we have to.

What you don't have to do is tell Perl what kind of data you're going to keep in the variable.  Perl is very flexible about that and can deal with all kinds of data, even converting between types as needed.  This is convenient, but you give up some efficiency and speed for this convenience.  So if you find yourself wishing your program were faster, you may want to move to a different language.

Perl only really has one data type, called a scalar.  Scalar variables are identified by a dollar sign at their beginning (like $var).  Scalars are declared with the my keyword:

my $var;

"var" is the name of the variable.  Variable names in Perl are case sensitive, so "var" is not the same as "Var".  Choosing variable names is important - you want them to indicate what the variable is for, but you want to keep it short enough to be manageable.

You can also assign a value to a variable at the time of declaration:

my $var = 1;
my $lastname = "Smith";

(OK, we've introduced a new thing here - the "=" is the assignment operator.  We'll get back to that in a minute.)

There are two other types of variables, but they're just groups of scalars.

Arrays are a series of scalars.  They are identified by a "@" at their beginning (like @addresses).  An array can contain any number of scalars (well, almost any number), and you identify each scalar by number (like @addresses[0] or @addresses[1]).

Just as with counting, you start at zero.  The first item is item number zero.  Which takes a little getting used to.

Hashes are pairs of linked arrays, so you can think of them as an array of arrays.  Hashes are identified by a "%" at their beginning (like %price).  Hashes are basically a rudimentary database.  They are awesome, but they take some learning.

We'll get back to arrays and hashes in a while.

From here on out, we're going to leave out the header part of the program to save space.  The full program will be in the github repository, of course.

03_hello_world.pl

	my $hello_string;
	$hello_string = "Hello, World!\n";
	print( "$hello_string" );

So here, we're declaring a scalar variable named $hello_string, then we're putting the data "Hello, World!\n" into the variable (writing to memory), then we're using the variable in the string we feed to the print function.

When Perl sees a scalar variable name inside double quotes, it "interpolates" the variable - meaning it replaces the variable name with the data stored in the variable.  So,

	print "$hello_string";

is functionally the same as 

	print "Hello, World!\n";

The value of a variable can change (hence the name, variable).  So you can do this:

	my $hello_string;

	$hello_string = "derp";
	$hello_string = "Hello, World!\n";

	print "$hello_string";

After the first assignment, $hello_string contains "derp".  The second replaces the string "derp" with "Hello, World!\n".

The "=" is the assignment operator.  It sets the thing to the left of the operator (our variable in this case) to the value of the thing to the right of the operator (our string in this case).

Just about anything can happen to the right of the assignment operator (or, indeed, most operators).  Including another variable:

	my $a = "Hello, World!\n";
	my $hello_string = $a;

04_variables.pl

	my $my_string;	# declare a variable named $my_string
	my $another_string = "blah blah blah";	# declare a variable and set it's value
	my ( $a, $b );	# declare two variables at once

	$my_string = "Hello, World!\n";	# set value of $my_string

	$another_string = $my_string;	# set value of $another_string to be same as $my_string

	$a = $b = 1;					# set both $a and $b to 1;

	print "\$my_string: $my_string\n";
	print "\$another_string: $another_string\n";
	print "\$a: $a\n";
	print "\$b: $b\n";

When you run this, you see:

	$my_string: Hello, World!

	$another_string: Hello, World!

	$a: 1
	$b: 1

Pop quiz: Why the blank lines after the Hello, World! strings?


Declaring variables

You declare a variable using the "my" keyword.  You can declare more than one variable with each "my" by putting them in parenthesis.  You can declare a variable and set it's value by using the assignment operator.


Setting variables

You set the value of a variable with the assignment operator ("=").

You can use a string, a number, or another variable to set the value of a variable.

Because assignment operators work from right to left, you can assign a variable and use the value of that variable to set another variable.

You should always set the value of a variable before you use it.  The warnings module will warn you if you do not.  In theory, every unassigned variable has a special value called undef, but you may find things don't work predictably if you don't assign values before using variables.


Variables and strings

Text in between double quote marks are a string.  If you put a scalar variable in a string, Perl substitutes the variable name for the contents of the variable.

But what if we want to put the name of the variable in a string?  You have to "escape" the "$" character by putting a backslash in front of it ("\$").  This makes perl actually put in a dollar sign character in the string instead of using it for a variable name.  This also works for other special characters like double quotes and such.


Functions

Functions are like little programs that you run inside a program.  They have inputs (parameters) and outputs (return values).  Their output can be assigned to a variable or used as a parameter for another function.

Function names, like variable names, are case-sensitive.

Perl has many built-in functions.  Print is a function, for example.

You can also define your own functions with the sub keyword.  (sub is short for subroutine, which is what they are called in BASIC.)

In most programming languages, functions are called by using their name followed by parenthesis, with any parameters inside the parenthesis, separated by commas.

	function( a, b, c );

You can do this in Perl, too.  Or not.  Perl doesn't really care.  Perl is like the Honey Badger of programming languages.

It comes down to programming style.  I personally use parenthesis a lot - I think they help keep the code readable.  But you don't have to.

05_functions.pl

	my $my_string = "blah blah blah";
	my $string_length = length( $my_string );

	print( $my_string . "\n" );		# classic function form
	print $my_string . "\n";		# look ma, no parenthesis!

	print "\"$my_string\" is " . length( $my_string ) . " characters long\n";
	print "\"$my_string\" is $string_length characters long\n";

	my_function( $my_string );

	my $result = how_long( $my_string );
	print "\"$my_string\" is $result characters long\n";
	print "\"$my_string\" is " . how_long( $my_string ) . " characters long\n";

	$result = my_function();
	print "my_function returned $result\n";

	sub my_function {
		my $param = @_[0];
		print "You said \"$param\"\n";
	}

	sub how_long {
		my $param = $_[0];
		return length( $param );
	}

Output of the program:

	blah blah blah
	blah blah blah
	"blah blah blah" is 14 characters long
	"blah blah blah" is 14 characters long
	You said "blah blah blah"
	"blah blah blah" is 14 characters long
	"blah blah blah" is 14 characters long
	You said ""
	my_function returned 1

OK, lots of new things here.

"." is an operavtor.  It concatenates two strings together.  So you can add a newline character to the end of another string.

We're also using the escaped double quote to put a double quote character inside a string.

length() is a built-in function that returns an integer - the length of a string.  You can assign it's output to a variable or you can use it as the parameter for another function such as print().

There are two defined functions here: my_function() and how_long().  They use the sub keyword and have a code block surrounded by curly braces to define the function.  my_function() does not return a value.  Well, as we see it technically does.  Any function without an explicit return value simply returns "1" indicating success.

how_long() explicitly returns the length of a string passed to it.  This is kind of pointless since we have the built-in length() function, but we could be counting the number of spaces or uppercase letters of something else instead.

A function's return value is set using the return() function.

Also notice this:

	my $param = @_[0];

This is how we get the parameter passed to the function.  @_ is an array.  @_[0] is the first item in the array (remember, start with zero).  @_ is a special built-in variable you don't need to declare because it's built-in to Perl.  Perl takes all of the parameters passed to a function and puts them into the array @_.  The first parameter is in the first item of the array, the second in the second, etc.

Notice in one sub I use @_[0] and the other $_[0].  They both work.  The array is called @_, but when we precede an array with the scalar variable type, Perl converts the array value to a scalar.  However, since we're putting @_[0] into a scalar, Perl figures we want it converted and does it anyhow.  Technically, $_[0] is more correct.  But Perl is generally pretty smart about what you want to do.

If you find yourself doing the same thing over and over again in your program, consider making it a function.


Scope

Notice that I declare $param in both subs.  Normally with use strict on, declaring a variable twice would cause an error.  Why does this work?

Variables have a "scope" which defines where that variable is valid and can be used.  When you declare a variable inside a code block (a chunk of code between curly braces), the variable is created at the point where it is declared, and it is destroyed at the end of the code block.  The variable is said to have local scope.

Variables declared outside of any code blocks are said to have global scope and are available everywhere in the program.

You can declare a variable inside a code block with the same name as a global variable.  It essentially replaces (while in scope) the global variable.

Scope can be confusing.  And re-using variable names can increase the confusion, so keep it to a minimum.  There are a few variables I will use in multiple scopes, such as function parameters, like above.  But it's dangerous and the results can be unpredictable.  So just don't.


Operators

We've seen a couple operators so far.  But "=" and "." seem to do different things.  But they're both operators.  And they have similar properties.

Operators do things to bits of memory (variables or output of functions), such as addition. There are other operators that mostly do variations on addition (again, this is a bit of an oversimplification).

06_operators.pl

	my ( $a, $b, $c );
	my $my_string = "foo";

	$a = 2;
	$b = 5;
	$c = 2 + 2;
	print "result is $c\n";
	$c = $a + $b;
	print "result is $c\n";
	$c = $a * $b;
	print "result is $c\n";
	$c += $a;
	print "result is $c\n";
	$c *= $b;
	print "result is $c\n";
	$c++;

	if ( $c >= 60 ) {
		print "\$c is greater than or equal to 60\n";
	} else {
		print "\$c is less than 60\n";
	}

	print "\$c is $c\n";
	if ( $c-- == 60 ) { print "\$c is exactly 60\n"; }
	else { print "\$c is NOT 60\n"; }

	print "\$c is $c\n";
	if ( --$c == 60 ) { print "\$c is exactly 60\n"; }
	else { print "\$c is NOT 60\n"; }

	if ( $c != 0 ) { print "\$c is not zero\n"; }
	print "\$c is $c\n";

	print "$c" . " " x 5 . "\n";
	print "$c " x 5 . "\n";

	if ( $my_string = "foo" ) { print "\$my_string = \"foo\"\n"; }
	if ( $my_string = "bar" ) { print "\$my_string = \"bar\"\n"; }
	if ( $my_string == "foo" ) { print "\$my_string == \"foo\"\n"; }
	if ( $my_string == "bar" ) { print "\$my_string == \"bar\"\n"; }
	if ( $my_string eq "foo" ) { print "\$my_string eq \"foo\"\n"; }
	if ( $my_string eq "bar" ) { print "\$my_string eq \"bar\"\n"; }
	if ( $my_string ne "foo" ) { print "\$my_string ne \"foo\"\n"; }
	if ( $my_string ne "bar" ) { print "\$my_string ne \"bar\"\n"; }
	print "$my_string\n";

Output:

	result is 4
	result is 7
	result is 10
	result is 12
	result is 60
	$c is greater than or equal to 60
	$c is 61
	$c is NOT 60
	$c is 60
	$c is NOT 60
	$c is not zero
	$c is 59
	59     
	59 59 59 59 59 
	$my_string = "foo"
	$my_string = "bar"
	$my_string == "foo"
	$my_string == "bar"
	$my_string eq "bar"
	$my_string ne "foo"
	bar

OK.  Lots of operators.  Perl has lots of operators.  It's not important that you learn all of them right away, but here are some examples:

= is the assignment operator - makes the item on the left equal to the item on the right.
+ is addition - adds the left and right together
- / * other math operators
+= adds the right to the left and puts the result in the left, unlike + which just evaluates to the result and needs to be used with an operator or as a parameter.
-= *= /= same thing but for other math functions.
++ increment operator - adds 1.
-- decrement operator - subtracts 1.
== equality operator - checks for equality of the left and right and evaluates to 1 if they match and 0 if they do not.
> greater than comparison operator - evaluates to 1 if left is greater than right.
< less than comaprison operator - evaluates to 1 if left is less than right.
>= greater than or equal to comparison operator - evaluates to 1 if left is greater than or equal to the right, 0 otherwise.
<= less than or equal to comaprison operator.
!= inequality operator - evaluates to 1 if left and right are not equal, 0 otherwise.
x repetition operator repeats the left by the number on the right
. concatenation operator - evaluates to the left and right concatenated together (does not modify the left)
.= concatenation operator - modifies the left by concatenating the right.
eq string equality operator - compares left and right as strings, evaluates to 1 if they are equal, 0 otherwise.
ne string inequality operator - opposite of eq.
lt string less than operator - compares left and right and evaluates to 1 if left is stringwise less then right.
gt string greater than operator - compares left and right and evaluates to 1 if left is stringwise greater then right.

We are also doing conditional branching with if statements.

if(){}else{} executes the code block if the expression in the parenthesis evaluates to 1.  Otherwise it executes the else code block.

Most of these operators are pretty straightforward.  But some get confusing.

+ vs +=
- vs -=

+, -, *, and / are standard arithmetic operators.  Like '.' they operate on the thing on the left and the thing on the right, and return the result.  But they leave both things (left and right) unchanged.

+=, -=, *=, and /= work the same, but they modify the thing on the left to contain the result.  Think of $a += $b to mean "add $b to $a".  Whereas $a + $b is "what is $a plus $b?".


= vs ==

A very common mistake is trying to use = to test for equality.

	my $a = 1;
	if ( $a = 2 ) { print "$a\n"; }

Here $a starts out as 1, but in the second line where we want to test to see if it is 2, we are actually assigning it to be 2.

The assignment operator evaluates to 1 because the assignment was successful, so it prints the value of $a, and it's different from what we first assigned to it.

Instead we want to use == to test the value of $a:

	my $a = 1;
	if ( $a == 2 ) { print "$a\n"; }

In this case, $a is not equal to 2 so it does not print the value.


== vs eq

Perl tries to convert your variables for you, but sometimes it doesn't work out right.

Short story - use ==, !=, >, <, >=, <= to compare numbers and use eq, ne, lt, gt, lte, gte to comapre strings.  That way Perl knows what you're talking about.

If you use the wrong one (say you use == to compare strings) the result might not be what you expected.


++ and --

Increment and decrement operators can come before or after a variable name.  Where they are placed determines when they increment and decrement.  When before, the increment/decrement happens before the expression is evaluated.  When after, it happens after the expression is evaluated.  This is very important when it comes to comaprisons.

	my $a = 1;
	if ( $a++ == 1 ) { print "hooray!\n";}
	if ( $a++ == 1 ) { print "hooray!\n";}

The first if statement tests true because $a is 1 to start with.  But after the if() test, $a is incremented to be 2.  The second tests false because $a is no longer 1.  After the second if() test, $a is incremented to 3.

	my $a = 1;
	if ( ++$a == 1 ) { print "hooray!\n";}
	if ( ++$a == 1 ) { print "hooray!\n";}

In this case, $a is incremented to 2 before the equality test in the first if() statement, so it tests false.  $a is 3 for the second if() so it tests false as well.


Precedence and Associvity

What order are operators performed in?  There is an order in which operators are performed.  For math operators, it's generally the same as you were taught in Algebra.  * and / are done before + and -.

And if you have more than one operator with the same precedence in a row, they are mostly left associative (that is, they are done in left-to-right order).  Mostly.  There are some that are right associative.

There is a complete list of operator precedence and associativity at http://perldoc.perl.org/perlop.html.

If you can't keep track and you need things to be done in a particular order, you can control it by adding parenthesis around them.  And parenthesis can be nested (that is you can (or is it may?) parenthesis inside parenthesis).  Operators in the inner-most parenthesis are performed first.

07_precedence.pl

	my $result;
	$result = 2 + 4 * 5;	#	== 22
	$result = (2 + 4) * 5;	#	== 30
	$result = 8 - 4 - 2;	#	== 2
	$result = 8 - (4 - 2);	#	== 6


Flow Control

Perl is a procedural programming language.  Each program starts at the top and proceeds down line by line (or rather, statement by statement).  But if it always does exactly the same thing, it isn't that useful and you wouldn't need to run it more than once.  So we have what we call flow control to change the order in which we do things.

Flow control is managed with two things: conditional operators and subroutines.

We've seen examples of each of these now.  Subroutines are the functions defined with the sub keyword.


Conditional Branching

The if() statement was an example of a conditional operator.  But we used a simple version.  It can get a little more complicated:

	if ( $a	== 0 ) {
		... # do something here if $a is exactly 0
	} elsif ( $a > 0 ) {
		... # do something else if $a is positive
	} else {
		... # do something else if $a is negative
	}


Loops

Sometimes we need to do things more than once, maybe slightly differently each time.  Perl has several ways of doing this.

For loops are taken straight from C.

	for ( my $i = 0; $i < 10; $i++ ) {
		print( "$i\n" );
	}

There are three statements that make up the for loop:

1) An initialization (in this case, we declare a variable $i and initialize it to zero.
2) A test to continue with the loop (if test is true)
3) A statement to execute after each loop

We typically use $i as shorthand for index.  If you declare a variable in the for statement, it has scope for the code block which is run for each iteration of the loop.

The code block is executed if the test is true.  If you want to loop 10 times, the test would be that $i is less then 10.

After each loop, $i is incremented by 1.  After the 10th loop, the value of $i is 10.


There are other loop types as well:

	while( test ) { ... }

Performs the code block if the test expression is true.

	until( test ) { ... }

Performs the code block if the test expression is false.

	foreach( @array ) { ... }

Performs the code block for each item in array @array
	


08_ascii_table.pl

Here's a more practical example that uses looping and arrays and illustrates the data representation of text characters.

	my $output_string = "";
	my $num_cols = 8;		# should be a power of 2 (i.e., 2, 4, or 8)
	my $num_length = 3;		# should be at least 3

	# create the table contents
	for ( my $i = 0; $i < 256; $i++ ) {
		$output_string .= pad_with_leading_zeros( $i, $num_length ) . " ";
		if ( $i > 32 ) { $output_string .= chr( $i ); }
		$output_string .= "\n";
	}

	print( $output_string = format_into_columns( $output_string, $num_cols ) );

	# pad_with_leading_zeros( number, total_length)
	# add leading zeros to a number to make it the requested length
	sub pad_with_leading_zeros {
		my $number = shift;
		my $length = shift;
		my $return_string = "";
		for ( my $i = 0; $i < ( $length - length( $number ) ); $i++ ) {
			$return_string .= "0";
		}
		$return_string .= "$number";
		return( $return_string );
	}

	# format_into_columns( table, num_columns)
	# Take the 256 table entires and make columns out of it
	# Takes two parameters - the table and the number of desired columns
	sub format_into_columns {
		my @input_list = split( '\n', $_[0] );
		my $num_columns = $_[1];
		my $return_string = "";
	
		for ( my $row = 0; $row < ( 256 / $num_columns ); $row++ ) {
			for ( my $col = 0; $col < $num_columns; $col++ ) {
				$return_string .= "$input_list[(($row)+($col*(256/$num_columns)))]\t";
			}
			$return_string .= "\n";
		}
		return( $return_string );
	}

This outputs:

	000 	032 	064 @	096 `	128 ?	160 ?	192 ?	224 ?	
	001 	033 !	065 A	097 a	129 ?	161 ?	193 ?	225 ?	
	002 	034 "	066 B	098 b	130 ?	162 ?	194 ?	226 ?	
	003 	035 #	067 C	099 c	131 ?	163 ?	195 ?	227 ?	
	004 	036 $	068 D	100 d	132 ?	164 ?	196 ?	228 ?	
	005 	037 %	069 E	101 e	133 ?	165 ?	197 ?	229 ?	
	006 	038 &	070 F	102 f	134 ?	166 ?	198 ?	230 ?	
	007 	039 '	071 G	103 g	135 ?	167 ?	199 ?	231 ?	
	008 	040 (	072 H	104 h	136 ?	168 ?	200 ?	232 ?	
	009 	041 )	073 I	105 i	137 ?	169 ?	201 ?	233 ?	
	010 	042 *	074 J	106 j	138 ?	170 ?	202 ?	234 ?	
	011 	043 +	075 K	107 k	139 ?	171 ?	203 ?	235 ?	
	012 	044 ,	076 L	108 l	140 ?	172 ?	204 ?	236 ?	
	013 	045 -	077 M	109 m	141 ?	173 ?	205 ?	237 ?	
	014 	046 .	078 N	110 n	142 ?	174 ?	206 ?	238 ?	
	015 	047 /	079 O	111 o	143 ?	175 ?	207 ?	239 ?	
	016 	048 0	080 P	112 p	144 ?	176 ?	208 ?	240 ?	
	017 	049 1	081 Q	113 q	145 ?	177 ?	209 ?	241 ?	
	018 	050 2	082 R	114 r	146 ?	178 ?	210 ?	242 ?	
	019 	051 3	083 S	115 s	147 ?	179 ?	211 ?	243 ?	
	020 	052 4	084 T	116 t	148 ?	180 ?	212 ?	244 ?	
	021 	053 5	085 U	117 u	149 ?	181 ?	213 ?	245 ?	
	022 	054 6	086 V	118 v	150 ?	182 ?	214 ?	246 ?	
	023 	055 7	087 W	119 w	151 ?	183 ?	215 ?	247 ?	
	024 	056 8	088 X	120 x	152 ?	184 ?	216 ?	248 ?	
	025 	057 9	089 Y	121 y	153 ?	185 ?	217 ?	249 ?	
	026 	058 :	090 Z	122 z	154 ?	186 ?	218 ?	250 ?	
	027 	059 ;	091 [	123 {	155 ?	187 ?	219 ?	251 ?	
	028 	060 <	092 \	124 |	156 ?	188 ?	220 ?	252 ?	
	029 	061 =	093 ]	125 }	157 ?	189 ?	221 ?	253 ?	
	030 	062 >	094 ^	126 ~	158 ?	190 ?	222 ?	254 ?	
	031 	063 ?	095 _	127 	159 ?	191 ?	223 ?	255 ?	

Let's look at the specifics.

Since we are formatting text output, we have a couple things to control that formatting.  We could have just put these as values in the code, but it's generally better to make them variables at the top of the program and document them with comments to make them controls that can be tweaked.

	my $num_cols = 8;		# should be a power of 2 (i.e., 2, 4, or 8)
	my $num_length = 3;		# should be at least 3

We use a for loop to count from 0 to 255 with a for loop.  We are using the chr() function to convert the number 0..255 into it's ASCII equivalent character.  (There is a function that does the opposite - ord().)  We are using a sub function to add leading zeros to the number so that everything lines up neatly.

	for ( my $i = 0; $i < 256; $i++ ) {
		$output_string .= pad_with_leading_zeros( $i, $num_length ) . " ";
		if ( $i > 32 ) { $output_string .= chr( $i ); }
		$output_string .= "\n";
	}

The sub function takes two parameters - the number to pad and the total length we want it to be.

Remember before we used the special @_ array to get the parameters passed to the function?  Remember rule one?  There are multiple ways of getting the values from that array.  In this case, we're using the shift() function.

Shift returns the first item from an array, removing it from the array.  We could have said shift( @_ ).  But when we don't specify an array, it defaults to @_.  Which is convenient shorthand, but if you don't know Perl, it's not particularly obvious.

We are using another for loop to step through the leading zeros, and adding them to the output string.  Then we add the actual number.  We cause the sub function to return the string we've built by using the return() function.

	sub pad_with_leading_zeros {
		my $number = shift;
		my $length = shift;
		my $return_string = "";
		for ( my $i = 0; $i < ( $length - length( $number ) ); $i++ ) {
			$return_string .= "0";
		}
		$return_string .= "$number";
		return( $return_string );
	}

The other sub function takes the list, which is formatted one number and it's corresponding character per line, and breaks it into multiple columns.

We are using two for loops - one nested inside the other.  The inner loop executes once for each instance of the outer loop.  We are building the table one row at a time, so with our default 8 column format, we need to step by 32s: 0, 32, 64, 96, 128, 160, 192, 224.

To be able to access the needed item in the list, we put it into an array using the split() function.  split() is awesome.  You give it a scalar with delimited data and tell it what the delimiter is.  split() breaks the scalar apart between the delimiters and puts them into the array.  The delimiter gets left out.  The delimiter doesn't have to be a single character - it can be a complicated expression.

In this case, the delimiter is the newline character separating each line.  So we end up with an array of 256 elements, one for each item in the table.

	sub format_into_columns {
		my @input_list = split( '\n', $_[0] );
		my $num_columns = $_[1];
		my $return_string = "";
	
		for ( my $row = 0; $row < ( 256 / $num_columns ); $row++ ) {
			for ( my $col = 0; $col < $num_columns; $col++ ) {
				$return_string .= "$input_list[(($row)+($col*(256/$num_columns)))]\t";
			}
			$return_string .= "\n";
		}
		return( $return_string );
	}

The opposite of split() is join().



Input

Just like functions have input parameters, our program does too.  Like sub function parameters, the program's parameters are put in a special array, @ARGV.  The simplest use of the command line parameters is echoing them back to the output.

09_echo.pl

	print "@ARGV\n";

If you don't specify any parameters, it doesn't seem to do anything:

	$ perl 09_echo.pl

	$

But if you add something, that is the result:

	$ perl 09_echo.pl foo
	foo
	$

You can parse multiple parameters by grabbing the different elements of @ARGV.

The other type of user input is taking input from the keyboard while the program is running.  They keyboard input is called STDIN, or standard input (the output to the console is STDOUT).

In Perl, STDIN and STDOUT are handled as a special kind of file.  We'll see more about how files work in a bit.

If we want to read from the keyboard, we use the <STDIN> file handle.  <> is a shortcut, as the default file handle is STDIN.

10_echo_name.pl

	my ( $name, @full_name );

	if ( $ARGV[0] eq undef ) {
		print "Please type your first and last name\n";
		chomp( $name = <STDIN> );
		@full_name = split( /\s+/, $name );
		print( respond( $full_name[0], $full_name[1] ) );
	} else {
		print( respond( $ARGV[0], $ARGV[1] ) );
	}

	sub respond {
		my $first = shift;
		my $last = shift;
		return( "Hello, $first, I see your last name is $last\n" );
	}

You'll notice that Perl will complain about use of an uninitialized variable when trying to read $ARGV[0].  Once you work out any problems in your program, you can remove the "use warnings" to get rid of this message.

There's only one new thing here, really:

	chomp( $name = <STDIN> );

<STDIN> prompts the user to type their name (if one wasn't typed as command line parameters).  It stops when they hit return.

chomp() is a function that is very useful - you'll see it frequently.  It cleans up input to remove any trailing non-printing bits (like the return).

Perl does the $name = <STDIN> first, and chomp() is performed on the resulting $name.  You could do this as well:

	my $name = <STDIN>;
	chomp( $name );

But the tendency in Perl is to combine lines when possible.  It's easy to get carried away with this and render code unreadable, which gives Perl it's reputation for being indecipherable.  So try not to get carried away.

This program only does minimal error checking.  It determines if any command line parameters were passed by checking the first one only.  It doesn't look for a last name, and it doesn't try to check if first and last name are valid names at all.  If there are no command line parameters passed, it trusts that the user will type a name when prompted.  You can create nonsensical output by typing unexpected input.  Part of programming is expecting the unexpected, or at least checking for it, and figuring out how to deal with it gracefully.


Files

Perl isn't actually an acronym (note it's not all caps).  But Larry Wall, creator of Perl says it's short for "Practical Extraction and Report Language."

Perl was created by Wall to parse through files and generate reports.  This is what it excels at.  As a result, Perl has strong file handling capabilities.

To read from or write to a file, we have to open it using the open() function.  We refer to open files with filehandles.  When we are done with a file, we close it with the close() function.

Writing to a file is easy.  There is, unfortunately, no write() function.  Instead, we use the print() function, specifying the filehandle.

There are multiple ways to read from a file.

Text files can be read a line at a time using the diamond operator specifying the filehandle.  This is convenient for parsing through log files and such.

For reading more than one line at a time, or from binary files, we can use the read() function.


Regular Expressions

One of the most powerful features of Perl, particularly for parsing files, are regular expressions.  Entire books have been written about Regular Expressions, so we can only scratch the surface.

// (or m//) is the matching operator.  If the expression inside the slashes, it evaluates to true.  We use the =~ operator to indicate what variable to perform the match on.

	my $search_text = "foo";
	if ( $search_text =~ /foo/ ) { print "match!\n"; }

For the most part, in regular expressions, characters match themselves.  There are a number of special characters.  A period ('.') matches any character, for example.  To match one of these special character, you must escape them with a backslash.  \. would match a literal period.

s/// the substitution operator.  Any match between the first two slashes is replaced by the expression between the last two.

	my $search_text = "foo";
	$search_text =~ s/f//;	# replace 'f' with nothing
	# $search_text is now "oo"

Another seriously useful feature of regular expressions is backreferences.  If part of an expression surrounded by parenthesis, a match for that part is placed into a special variable and can be used later.  You can have up to 9 backreferences in an expression, and they are stored in variables named $1, $2, $3, etc.

	my $search_text = "2013-06-20";
	$search_text =~ s/([0-9]{4})-([0-9]{2})-([0-9]{2})/$2\/$3\/$1/;
	# $search_text is reformatted to "06/20/2013"

Square brackets indicate groups of characters to match on.  [0-9] match any number from 0-9.  Curly braces indicate a number of repeats of the previous character, so [0-9]{4} matches any four-digit number from 0000 to 9999.


Debugging

When things go wrong, it can be difficult to figure out what happened.

Perl has a debugger mode which can be helpful, but it's a bit complex.  I usually put in a variable which is a debug flag, and at key points, I check for the flag and print status and variable values to the shell.


11_files.pl

Lots of new things in this one.

Relying on the standard @ARGV array can be very limiting.  Many Linux command line programs use more complicated and flexible command line options.  Perl has a standard module called Getopt::Long that gives us very sophisticated command line option options.

To take advantage of this module, we have to use it first.

	use Getopt::Long;

	my ( $input_param, $output_param, $start_param, $end_param );
	my ( $help_param, $version_param, $debug_param, $line_date );

	GetOptions( 'input|i=s'		=>	\$input_param,
				'output|o=s'	=>	\$output_param,
				'start=s'		=>	\$start_param,
				'end=s'			=>	\$end_param,
				'help|?'		=>	\$help_param,
				'version'		=>	\$version_param,
				'debug!'		=>	\$debug_param );

Then we need to define some variables that the contents of the command line options.

Finally, we use the GetOptions() function to parse the command line options.  GetOptions() is very powerful and complicated, but here are the basics:

We're defining pairs of values - a command line option and a variable to put the value of that option in to.  We are using the => operator to assign an option to a variable, to make the parameters for GetOptions() more clear, but => is effectively the same thing as a comma.

The command line options are preceded by a dash for single character option, or a double dash for a multi-character option.  An option can have multiple choices, separated by a pipe character '|'.  So, in this case, we can use --input or -i.

Some options are just boolean flags (such as --help, --version, or --debug).  If we add an exclamation point, we can negate the flag with no (such as --nodebug). The variable is loaded with true if the option is added to the command line (--debug), false if it is negated (--nodebug), and is left undefined if it is not present on the command line.

If we follow the option with a equal sign, the option expects a value.  The character after the equal sign indicates the type of value.  =s indicates a string.  =i indicates a numeric value.  So, for input, we can put in "--input logfile.txt".  The value passed is put in the variable.  If the option is not passed, the variable is left undefined.

The variable specified is escaped with a backslash because we want to pass the variable itself and not the contents of the variable.











#####




hashes

packages/object-oriented programming

cpan



http://perldoc.perl.org/


http://programming-motherfucker.com/








statements
variables
data representation
expressions
blocks
operators
functions
subroutines
regular expressions
hashes
input
output
files





